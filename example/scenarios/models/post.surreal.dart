// GENERATED CODE - DO NOT MODIFY BY HAND
// dart format width=80

part of 'post.dart';

// **************************************************************************
// SurrealTableGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by SurrealTableGenerator

/// TableDefinition for Post
final postTableDefinition = TableStructure(
  'posts',
  {
    'title': FieldDefinition(
      StringType(),
    ),
    'content': FieldDefinition(
      StringType(),
    ),
    'status': FieldDefinition(
      StringType(),
      defaultValue: 'draft',
    ),
    'createdAt': FieldDefinition(
      DatetimeType(),
    ),
    'updatedAt': FieldDefinition(
      DatetimeType(),
      optional: true,
    ),
  },
);

// ORM Extension for Post
extension PostORM on Post {
  /// Converts this Post instance to a SurrealDB-compatible Map.
  ///
  /// This method is used internally by the ORM layer to serialize
  /// Dart objects before sending them to the database.
  Map<String, dynamic> toSurrealMap() {
    return {
      'title': title,
      'content': content,
      'status': status,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt?.toIso8601String(),
    };
  }

  /// Validates this Post instance against its table schema.
  ///
  /// This method checks that all field values conform to the defined
  /// constraints in the TableStructure.
  ///
  /// Throws [OrmValidationException] if validation fails.
  void validate() {
    try {
      postTableDefinition.validate(toSurrealMap());
    } on ValidationException catch (e) {
      throw OrmValidationException(
        'Validation failed for Post',
        field: e.fieldName,
        constraint: e.constraint,
        cause: e,
      );
    }
  }

  /// Gets the ID of this record.
  String? get recordId => id;

  /// Gets the table name for this entity.
  ///
  /// This is used by the ORM layer to determine which table
  /// to perform operations on.
  static String get tableName => 'posts';

  /// Gets the TableStructure for this entity.
  ///
  /// This is used by the ORM layer for schema validation
  /// and introspection.
  static TableStructure get tableStructure => postTableDefinition;

  /// Creates a Post instance from a SurrealDB Map.
  ///
  /// This method is used internally by the ORM layer to deserialize
  /// database results into Dart objects.
  ///
  /// Throws [OrmSerializationException] if required fields are missing
  /// or if type conversion fails.
  static Post fromSurrealMap(Map<String, dynamic> map) {
    // Validate required fields
    if (!map.containsKey('title')) {
      throw OrmSerializationException(
        'Required field "title" is missing from map',
        type: 'Post',
        field: 'title',
      );
    }
    if (!map.containsKey('content')) {
      throw OrmSerializationException(
        'Required field "content" is missing from map',
        type: 'Post',
        field: 'content',
      );
    }
    if (!map.containsKey('status')) {
      throw OrmSerializationException(
        'Required field "status" is missing from map',
        type: 'Post',
        field: 'status',
      );
    }
    if (!map.containsKey('createdAt')) {
      throw OrmSerializationException(
        'Required field "createdAt" is missing from map',
        type: 'Post',
        field: 'createdAt',
      );
    }

    try {
      return Post(
        title: map['title'] as String,
        content: map['content'] as String,
        status: map['status'] as String,
        createdAt: DateTime.parse(map['createdAt'] as String),
        updatedAt: map['updatedAt'] != null
            ? DateTime.parse(map['updatedAt'] as String)
            : null,
      );
    } catch (e) {
      throw OrmSerializationException(
        'Failed to deserialize Post from map',
        type: 'Post',
        cause: e is Exception ? e : Exception(e.toString()),
      );
    }
  }

  /// Creates a query builder for Post.
  ///
  /// This method is used internally by Database.query<Post>()
  /// to create type-safe query builders.
  static PostQueryBuilder createQueryBuilder(Database db) {
    return PostQueryBuilder._(db);
  }

  /// Relationship metadata for Post
  static const relationshipMetadata = <String, Map<String, dynamic>>{
    'author': {
      'fieldName': 'author',
      'targetType': 'User',
      'isList': false,
      'isOptional': true,
      'type': 'RecordLink',
      'effectiveTableName': 'user',
    },
  };
}

// Where Builder for Post
/// Type-safe where condition builder for Post entities.
///
/// This class provides field accessors that return condition builders
/// with type-safe operator methods.
///
/// Example:
/// ```dart
/// final users = await db.query<Post>()
///   .where((t) => t.fieldName.equals(value))
///   .execute();
/// ```
class PostWhereBuilder {
  /// Condition builder for the title field.
  StringFieldCondition get title => StringFieldCondition('title');

  /// Condition builder for the content field.
  StringFieldCondition get content => StringFieldCondition('content');

  /// Condition builder for the status field.
  StringFieldCondition get status => StringFieldCondition('status');

  /// Condition builder for the createdAt field.
  DateTimeFieldCondition get createdAt => DateTimeFieldCondition('createdAt');

  /// Condition builder for the updatedAt field.
  DateTimeFieldCondition get updatedAt => DateTimeFieldCondition('updatedAt');
}

// Query Builder for Post
/// Type-safe query builder for Post entities.
///
/// This class provides a fluent API for building queries against
/// the posts table with compile-time type safety.
///
/// Example:
/// ```dart
/// final results = await db.query<Post>()
///   .where((t) => t.field.equals(value))
///   .limit(10)
///   .orderBy('name', ascending: true)
///   .execute();
/// ```
class PostQueryBuilder {
  final Database _db;
  int? _limit;
  int? _offset;
  String? _orderByField;
  bool _orderByAscending = true;
  WhereCondition? _whereCondition;
  final Map<String, dynamic> _legacyWhereConditions = {};

  /// Private constructor - use Database.query<Post>() instead.
  PostQueryBuilder._(this._db);

  /// Adds a where condition using the type-safe where builder.
  ///
  /// Example:
  /// ```dart
  /// .where((t) => t.age.greaterThan(18) & t.status.equals('active'))
  /// ```
  PostQueryBuilder where(WhereCondition Function(PostWhereBuilder) builder) {
    final whereBuilder = PostWhereBuilder();
    _whereCondition = builder(whereBuilder);
    return this;
  }

  /// Sets the maximum number of results to return.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  PostQueryBuilder limit(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Limit must be non-negative');
    }
    _limit = count;
    return this;
  }

  /// Sets the number of results to skip before returning.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  PostQueryBuilder offset(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Offset must be non-negative');
    }
    _offset = count;
    return this;
  }

  /// Sets the field to order results by.
  ///
  /// Parameters:
  /// - [field]: The field name to sort by
  /// - [ascending]: Sort direction (default: true)
  PostQueryBuilder orderBy(String field, {bool ascending = true}) {
    _orderByField = field;
    _orderByAscending = ascending;
    return this;
  }

  /// Adds an equals condition for the title field (legacy method).
  ///
  /// Consider using .where((t) => t.title.equals(value)) instead.
  PostQueryBuilder whereTitleEquals(String value) {
    _legacyWhereConditions['title'] = value;
    return this;
  }

  /// Adds an equals condition for the content field (legacy method).
  ///
  /// Consider using .where((t) => t.content.equals(value)) instead.
  PostQueryBuilder whereContentEquals(String value) {
    _legacyWhereConditions['content'] = value;
    return this;
  }

  /// Adds an equals condition for the status field (legacy method).
  ///
  /// Consider using .where((t) => t.status.equals(value)) instead.
  PostQueryBuilder whereStatusEquals(String value) {
    _legacyWhereConditions['status'] = value;
    return this;
  }

  /// Adds an equals condition for the createdAt field (legacy method).
  ///
  /// Consider using .where((t) => t.createdAt.equals(value)) instead.
  PostQueryBuilder whereCreatedAtEquals(DateTime value) {
    _legacyWhereConditions['createdAt'] = value;
    return this;
  }

  /// Adds an equals condition for the updatedAt field (legacy method).
  ///
  /// Consider using .where((t) => t.updatedAt.equals(value)) instead.
  PostQueryBuilder whereUpdatedAtEquals(DateTime value) {
    _legacyWhereConditions['updatedAt'] = value;
    return this;
  }

  /// Executes the query and returns the results.
  ///
  /// Returns a list of Post instances matching the query criteria.
  ///
  /// Throws [QueryException] if the query fails.
  Future<List<Post>> execute() async {
    // Build SELECT query
    final buffer = StringBuffer('SELECT * FROM posts');

    // Add WHERE clauses
    final whereClauses = <String>[];

    // Add type-safe where condition
    if (_whereCondition != null) {
      whereClauses.add(_whereCondition!.toSurrealQL(_db));
    }

    // Add legacy where conditions
    if (_legacyWhereConditions.isNotEmpty) {
      for (final entry in _legacyWhereConditions.entries) {
        final paramName = 'param_${entry.key}';
        await _db.set(paramName, entry.value);
        whereClauses.add('${entry.key} = \$$paramName');
      }
    }

    if (whereClauses.isNotEmpty) {
      buffer.write(' WHERE ');
      buffer.write(whereClauses.join(' AND '));
    }

    // Add ORDER BY clause
    if (_orderByField != null) {
      buffer.write(' ORDER BY $_orderByField');
      buffer.write(_orderByAscending ? ' ASC' : ' DESC');
    }

    // Add LIMIT clause
    if (_limit != null) {
      buffer.write(' LIMIT $_limit');
    }

    // Add OFFSET/START clause
    if (_offset != null) {
      buffer.write(' START $_offset');
    }

    // Execute query
    final response = await _db.queryQL(buffer.toString());
    final results = response.getResults();

    // Deserialize results
    return results.map((map) => PostORM.fromSurrealMap(map)).toList();
  }

  /// Executes the query and returns the first result, or null if no results.
  ///
  /// This is a convenience method equivalent to `.limit(1).execute()`
  /// followed by returning the first element or null.
  Future<Post?> first() async {
    final results = await limit(1).execute();
    return results.isEmpty ? null : results.first;
  }
}
