// GENERATED CODE - DO NOT MODIFY BY HAND
// dart format width=80

part of 'listeners.dart';

// **************************************************************************
// SurrealTableGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by SurrealTableGenerator

/// TableDefinition for Listeners
final listenersTableDefinition = TableStructure(
  'listeners',
  {
    'name': FieldDefinition(
      StringType(),
    ),
    'threadId': FieldDefinition(
      StringType(),
      indexed: true,
    ),
    'type': FieldDefinition(
      StringType(),
    ),
  },
);

// ORM Extension for Listeners
extension ListenersORM on Listeners {
  /// Converts this Listeners instance to a SurrealDB-compatible Map.
  ///
  /// This method is used internally by the ORM layer to serialize
  /// Dart objects before sending them to the database.
  Map<String, dynamic> toSurrealMap() {
    return {
      'name': name,
      'threadId': threadId,
      'type': type,
    };
  }

  /// Validates this Listeners instance against its table schema.
  ///
  /// This method checks that all field values conform to the defined
  /// constraints in the TableStructure.
  ///
  /// Throws [OrmValidationException] if validation fails.
  void validate() {
    try {
      listenersTableDefinition.validate(toSurrealMap());
    } on ValidationException catch (e) {
      throw OrmValidationException(
        'Validation failed for Listeners',
        field: e.fieldName,
        constraint: e.constraint,
        cause: e,
      );
    }
  }

  /// Gets the ID of this record.
  String? get recordId => id;

  /// Gets the table name for this entity.
  ///
  /// This is used by the ORM layer to determine which table
  /// to perform operations on.
  static String get tableName => 'listeners';

  /// Gets the TableStructure for this entity.
  ///
  /// This is used by the ORM layer for schema validation
  /// and introspection.
  static TableStructure get tableStructure => listenersTableDefinition;

  /// Creates a Listeners instance from a SurrealDB Map.
  ///
  /// This method is used internally by the ORM layer to deserialize
  /// database results into Dart objects.
  ///
  /// Throws [OrmSerializationException] if required fields are missing
  /// or if type conversion fails.
  static Listeners fromSurrealMap(Map<String, dynamic> map) {
    // Validate required fields
    if (!map.containsKey('name')) {
      throw OrmSerializationException(
        'Required field "name" is missing from map',
        type: 'Listeners',
        field: 'name',
      );
    }
    if (!map.containsKey('threadId')) {
      throw OrmSerializationException(
        'Required field "threadId" is missing from map',
        type: 'Listeners',
        field: 'threadId',
      );
    }
    if (!map.containsKey('type')) {
      throw OrmSerializationException(
        'Required field "type" is missing from map',
        type: 'Listeners',
        field: 'type',
      );
    }

    try {
      return Listeners(
        name: map['name'] as String,
        threadId: map['threadId'] as String,
        type: map['type'] as String,
      );
    } catch (e) {
      throw OrmSerializationException(
        'Failed to deserialize Listeners from map',
        type: 'Listeners',
        cause: e is Exception ? e : Exception(e.toString()),
      );
    }
  }

  /// Creates a query builder for Listeners.
  ///
  /// This method is used internally by Database.query<Listeners>()
  /// to create type-safe query builders.
  static ListenersQueryBuilder createQueryBuilder(Database db) {
    return ListenersQueryBuilder._(db);
  }
}

// Where Builder for Listeners
/// Type-safe where condition builder for Listeners entities.
///
/// This class provides field accessors that return condition builders
/// with type-safe operator methods.
///
/// Example:
/// ```dart
/// final users = await db.query<Listeners>()
///   .where((t) => t.fieldName.equals(value))
///   .execute();
/// ```
class ListenersWhereBuilder {
  /// Condition builder for the name field.
  StringFieldCondition get name => StringFieldCondition('name');

  /// Condition builder for the threadId field.
  StringFieldCondition get threadId => StringFieldCondition('threadId');

  /// Condition builder for the type field.
  StringFieldCondition get type => StringFieldCondition('type');
}

// Query Builder for Listeners
/// Type-safe query builder for Listeners entities.
///
/// This class provides a fluent API for building queries against
/// the listeners table with compile-time type safety.
///
/// Example:
/// ```dart
/// final results = await db.query<Listeners>()
///   .where((t) => t.field.equals(value))
///   .limit(10)
///   .orderBy('name', ascending: true)
///   .execute();
/// ```
class ListenersQueryBuilder {
  final Database _db;
  int? _limit;
  int? _offset;
  String? _orderByField;
  bool _orderByAscending = true;
  WhereCondition? _whereCondition;
  final Map<String, dynamic> _legacyWhereConditions = {};

  /// Private constructor - use Database.query<Listeners>() instead.
  ListenersQueryBuilder._(this._db);

  /// Adds a where condition using the type-safe where builder.
  ///
  /// Example:
  /// ```dart
  /// .where((t) => t.age.greaterThan(18) & t.status.equals('active'))
  /// ```
  ListenersQueryBuilder where(
      WhereCondition Function(ListenersWhereBuilder) builder) {
    final whereBuilder = ListenersWhereBuilder();
    _whereCondition = builder(whereBuilder);
    return this;
  }

  /// Sets the maximum number of results to return.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  ListenersQueryBuilder limit(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Limit must be non-negative');
    }
    _limit = count;
    return this;
  }

  /// Sets the number of results to skip before returning.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  ListenersQueryBuilder offset(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Offset must be non-negative');
    }
    _offset = count;
    return this;
  }

  /// Sets the field to order results by.
  ///
  /// Parameters:
  /// - [field]: The field name to sort by
  /// - [ascending]: Sort direction (default: true)
  ListenersQueryBuilder orderBy(String field, {bool ascending = true}) {
    _orderByField = field;
    _orderByAscending = ascending;
    return this;
  }

  /// Adds an equals condition for the name field (legacy method).
  ///
  /// Consider using .where((t) => t.name.equals(value)) instead.
  ListenersQueryBuilder whereNameEquals(String value) {
    _legacyWhereConditions['name'] = value;
    return this;
  }

  /// Adds an equals condition for the threadId field (legacy method).
  ///
  /// Consider using .where((t) => t.threadId.equals(value)) instead.
  ListenersQueryBuilder whereThreadIdEquals(String value) {
    _legacyWhereConditions['threadId'] = value;
    return this;
  }

  /// Adds an equals condition for the type field (legacy method).
  ///
  /// Consider using .where((t) => t.type.equals(value)) instead.
  ListenersQueryBuilder whereTypeEquals(String value) {
    _legacyWhereConditions['type'] = value;
    return this;
  }

  /// Executes the query and returns the results.
  ///
  /// Returns a list of Listeners instances matching the query criteria.
  ///
  /// Throws [QueryException] if the query fails.
  Future<List<Listeners>> execute() async {
    // Build SELECT query
    final buffer = StringBuffer('SELECT * FROM listeners');

    // Add WHERE clauses
    final whereClauses = <String>[];

    // Add type-safe where condition
    if (_whereCondition != null) {
      whereClauses.add(_whereCondition!.toSurrealQL(_db));
    }

    // Add legacy where conditions
    if (_legacyWhereConditions.isNotEmpty) {
      for (final entry in _legacyWhereConditions.entries) {
        final paramName = 'param_${entry.key}';
        await _db.set(paramName, entry.value);
        whereClauses.add('${entry.key} = \$$paramName');
      }
    }

    if (whereClauses.isNotEmpty) {
      buffer.write(' WHERE ');
      buffer.write(whereClauses.join(' AND '));
    }

    // Add ORDER BY clause
    if (_orderByField != null) {
      buffer.write(' ORDER BY $_orderByField');
      buffer.write(_orderByAscending ? ' ASC' : ' DESC');
    }

    // Add LIMIT clause
    if (_limit != null) {
      buffer.write(' LIMIT $_limit');
    }

    // Add OFFSET/START clause
    if (_offset != null) {
      buffer.write(' START $_offset');
    }

    // Execute query
    final response = await _db.queryQL(buffer.toString());
    final results = response.getResults();

    // Deserialize results
    return results.map((map) => ListenersORM.fromSurrealMap(map)).toList();
  }

  /// Executes the query and returns the first result, or null if no results.
  ///
  /// This is a convenience method equivalent to `.limit(1).execute()`
  /// followed by returning the first element or null.
  Future<Listeners?> first() async {
    final results = await limit(1).execute();
    return results.isEmpty ? null : results.first;
  }
}
