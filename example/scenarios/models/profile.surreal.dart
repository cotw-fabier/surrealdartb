// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'profile.dart';

// **************************************************************************
// SurrealTableGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by SurrealTableGenerator

/// TableDefinition for Profile
final profileTableDefinition = TableStructure(
  'profiles',
  {
    'bio': FieldDefinition(
      StringType(),
      optional: true,
    ),
    'website': FieldDefinition(
      StringType(),
      optional: true,
    ),
    'location': FieldDefinition(
      StringType(),
      optional: true,
    ),
    'avatarUrl': FieldDefinition(
      StringType(),
      optional: true,
    ),
    'createdAt': FieldDefinition(
      DatetimeType(),
    ),
  },
);

// ORM Extension for Profile
extension ProfileORM on Profile {
  /// Converts this Profile instance to a SurrealDB-compatible Map.
  ///
  /// This method is used internally by the ORM layer to serialize
  /// Dart objects before sending them to the database.
  Map<String, dynamic> toSurrealMap() {
    return {
      'bio': bio,
      'website': website,
      'location': location,
      'avatarUrl': avatarUrl,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  /// Validates this Profile instance against its table schema.
  ///
  /// This method checks that all field values conform to the defined
  /// constraints in the TableStructure.
  ///
  /// Throws [OrmValidationException] if validation fails.
  void validate() {
    try {
      profileTableDefinition.validate(toSurrealMap());
    } on ValidationException catch (e) {
      throw OrmValidationException(
        'Validation failed for Profile',
        field: e.fieldName,
        constraint: e.constraint,
        cause: e,
      );
    }
  }

  /// Gets the ID of this record.
  String? get recordId => id;

  /// Gets the table name for this entity.
  ///
  /// This is used by the ORM layer to determine which table
  /// to perform operations on.
  static String get tableName => 'profiles';

  /// Gets the TableStructure for this entity.
  ///
  /// This is used by the ORM layer for schema validation
  /// and introspection.
  static TableStructure get tableStructure => profileTableDefinition;

  /// Creates a Profile instance from a SurrealDB Map.
  ///
  /// This method is used internally by the ORM layer to deserialize
  /// database results into Dart objects.
  ///
  /// Throws [OrmSerializationException] if required fields are missing
  /// or if type conversion fails.
  static Profile fromSurrealMap(Map<String, dynamic> map) {
    // Validate required fields
    if (!map.containsKey('createdAt')) {
      throw OrmSerializationException(
        'Required field "createdAt" is missing from map',
        type: 'Profile',
        field: 'createdAt',
      );
    }

    try {
      return Profile(
        bio: map['bio'] as String?,
        website: map['website'] as String?,
        location: map['location'] as String?,
        avatarUrl: map['avatarUrl'] as String?,
        createdAt: DateTime.parse(map['createdAt'] as String),
      );
    } catch (e) {
      throw OrmSerializationException(
        'Failed to deserialize Profile from map',
        type: 'Profile',
        cause: e is Exception ? e : Exception(e.toString()),
      );
    }
  }

  /// Creates a query builder for Profile.
  ///
  /// This method is used internally by Database.query<Profile>()
  /// to create type-safe query builders.
  static ProfileQueryBuilder createQueryBuilder(Database db) {
    return ProfileQueryBuilder._(db);
  }
}

// Where Builder for Profile
/// Type-safe where condition builder for Profile entities.
///
/// This class provides field accessors that return condition builders
/// with type-safe operator methods.
///
/// Example:
/// ```dart
/// final users = await db.query<Profile>()
///   .where((t) => t.fieldName.equals(value))
///   .execute();
/// ```
class ProfileWhereBuilder {
  /// Condition builder for the bio field.
  StringFieldCondition get bio => StringFieldCondition('bio');

  /// Condition builder for the website field.
  StringFieldCondition get website => StringFieldCondition('website');

  /// Condition builder for the location field.
  StringFieldCondition get location => StringFieldCondition('location');

  /// Condition builder for the avatarUrl field.
  StringFieldCondition get avatarUrl => StringFieldCondition('avatarUrl');

  /// Condition builder for the createdAt field.
  DateTimeFieldCondition get createdAt => DateTimeFieldCondition('createdAt');
}

// Query Builder for Profile
/// Type-safe query builder for Profile entities.
///
/// This class provides a fluent API for building queries against
/// the profiles table with compile-time type safety.
///
/// Example:
/// ```dart
/// final results = await db.query<Profile>()
///   .where((t) => t.field.equals(value))
///   .limit(10)
///   .orderBy('name', ascending: true)
///   .execute();
/// ```
class ProfileQueryBuilder {
  final Database _db;
  int? _limit;
  int? _offset;
  String? _orderByField;
  bool _orderByAscending = true;
  WhereCondition? _whereCondition;
  final Map<String, dynamic> _legacyWhereConditions = {};

  /// Private constructor - use Database.query<Profile>() instead.
  ProfileQueryBuilder._(this._db);

  /// Adds a where condition using the type-safe where builder.
  ///
  /// Example:
  /// ```dart
  /// .where((t) => t.age.greaterThan(18) & t.status.equals('active'))
  /// ```
  ProfileQueryBuilder where(
      WhereCondition Function(ProfileWhereBuilder) builder) {
    final whereBuilder = ProfileWhereBuilder();
    _whereCondition = builder(whereBuilder);
    return this;
  }

  /// Sets the maximum number of results to return.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  ProfileQueryBuilder limit(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Limit must be non-negative');
    }
    _limit = count;
    return this;
  }

  /// Sets the number of results to skip before returning.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  ProfileQueryBuilder offset(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Offset must be non-negative');
    }
    _offset = count;
    return this;
  }

  /// Sets the field to order results by.
  ///
  /// Parameters:
  /// - [field]: The field name to sort by
  /// - [ascending]: Sort direction (default: true)
  ProfileQueryBuilder orderBy(String field, {bool ascending = true}) {
    _orderByField = field;
    _orderByAscending = ascending;
    return this;
  }

  /// Adds an equals condition for the bio field (legacy method).
  ///
  /// Consider using .where((t) => t.bio.equals(value)) instead.
  ProfileQueryBuilder whereBioEquals(String value) {
    _legacyWhereConditions['bio'] = value;
    return this;
  }

  /// Adds an equals condition for the website field (legacy method).
  ///
  /// Consider using .where((t) => t.website.equals(value)) instead.
  ProfileQueryBuilder whereWebsiteEquals(String value) {
    _legacyWhereConditions['website'] = value;
    return this;
  }

  /// Adds an equals condition for the location field (legacy method).
  ///
  /// Consider using .where((t) => t.location.equals(value)) instead.
  ProfileQueryBuilder whereLocationEquals(String value) {
    _legacyWhereConditions['location'] = value;
    return this;
  }

  /// Adds an equals condition for the avatarUrl field (legacy method).
  ///
  /// Consider using .where((t) => t.avatarUrl.equals(value)) instead.
  ProfileQueryBuilder whereAvatarUrlEquals(String value) {
    _legacyWhereConditions['avatarUrl'] = value;
    return this;
  }

  /// Adds an equals condition for the createdAt field (legacy method).
  ///
  /// Consider using .where((t) => t.createdAt.equals(value)) instead.
  ProfileQueryBuilder whereCreatedAtEquals(DateTime value) {
    _legacyWhereConditions['createdAt'] = value;
    return this;
  }

  /// Executes the query and returns the results.
  ///
  /// Returns a list of Profile instances matching the query criteria.
  ///
  /// Throws [QueryException] if the query fails.
  Future<List<Profile>> execute() async {
    // Build SELECT query
    final buffer = StringBuffer('SELECT * FROM profiles');

    // Add WHERE clauses
    final whereClauses = <String>[];

    // Add type-safe where condition
    if (_whereCondition != null) {
      whereClauses.add(_whereCondition!.toSurrealQL(_db));
    }

    // Add legacy where conditions
    if (_legacyWhereConditions.isNotEmpty) {
      for (final entry in _legacyWhereConditions.entries) {
        final paramName = 'param_${entry.key}';
        await _db.set(paramName, entry.value);
        whereClauses.add('${entry.key} = \$$paramName');
      }
    }

    if (whereClauses.isNotEmpty) {
      buffer.write(' WHERE ');
      buffer.write(whereClauses.join(' AND '));
    }

    // Add ORDER BY clause
    if (_orderByField != null) {
      buffer.write(' ORDER BY $_orderByField');
      buffer.write(_orderByAscending ? ' ASC' : ' DESC');
    }

    // Add LIMIT clause
    if (_limit != null) {
      buffer.write(' LIMIT $_limit');
    }

    // Add OFFSET/START clause
    if (_offset != null) {
      buffer.write(' START $_offset');
    }

    // Execute query
    final response = await _db.queryQL(buffer.toString());
    final results = response.getResults();

    // Deserialize results
    return results.map((map) => ProfileORM.fromSurrealMap(map)).toList();
  }

  /// Executes the query and returns the first result, or null if no results.
  ///
  /// This is a convenience method equivalent to `.limit(1).execute()`
  /// followed by returning the first element or null.
  Future<Profile?> first() async {
    final results = await limit(1).execute();
    return results.isEmpty ? null : results.first;
  }
}
