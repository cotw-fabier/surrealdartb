// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user.dart';

// **************************************************************************
// SurrealTableGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by SurrealTableGenerator

/// TableDefinition for User
final userTableDefinition = TableStructure(
  'users',
  {
    'name': FieldDefinition(
      StringType(),
    ),
    'age': FieldDefinition(
      NumberType(format: NumberFormat.integer),
      assertClause: r'$value >= 18',
    ),
    'email': FieldDefinition(
      StringType(),
      assertClause: r'string::is::email($value)',
      indexed: true,
    ),
    'status': FieldDefinition(
      StringType(),
      defaultValue: 'active',
    ),
  },
);

// ORM Extension for User
extension UserORM on User {
  /// Converts this User instance to a SurrealDB-compatible Map.
  ///
  /// This method is used internally by the ORM layer to serialize
  /// Dart objects before sending them to the database.
  Map<String, dynamic> toSurrealMap() {
    return {
      'name': name,
      'age': age,
      'email': email,
      'status': status,
    };
  }

  /// Validates this User instance against its table schema.
  ///
  /// This method checks that all field values conform to the defined
  /// constraints in the TableStructure.
  ///
  /// Throws [OrmValidationException] if validation fails.
  void validate() {
    try {
      userTableDefinition.validate(toSurrealMap());
    } on ValidationException catch (e) {
      throw OrmValidationException(
        'Validation failed for User',
        field: e.fieldName,
        constraint: e.constraint,
        cause: e,
      );
    }
  }

  /// Gets the ID of this record.
  String? get recordId => id;

  /// Gets the table name for this entity.
  ///
  /// This is used by the ORM layer to determine which table
  /// to perform operations on.
  static String get tableName => 'users';

  /// Gets the TableStructure for this entity.
  ///
  /// This is used by the ORM layer for schema validation
  /// and introspection.
  static TableStructure get tableStructure => userTableDefinition;

  /// Creates a User instance from a SurrealDB Map.
  ///
  /// This method is used internally by the ORM layer to deserialize
  /// database results into Dart objects.
  ///
  /// Throws [OrmSerializationException] if required fields are missing
  /// or if type conversion fails.
  static User fromSurrealMap(Map<String, dynamic> map) {
    // Validate required fields
    if (!map.containsKey('name')) {
      throw OrmSerializationException(
        'Required field "name" is missing from map',
        type: 'User',
        field: 'name',
      );
    }
    if (!map.containsKey('age')) {
      throw OrmSerializationException(
        'Required field "age" is missing from map',
        type: 'User',
        field: 'age',
      );
    }
    if (!map.containsKey('email')) {
      throw OrmSerializationException(
        'Required field "email" is missing from map',
        type: 'User',
        field: 'email',
      );
    }
    if (!map.containsKey('status')) {
      throw OrmSerializationException(
        'Required field "status" is missing from map',
        type: 'User',
        field: 'status',
      );
    }

    try {
      return User(
        name: map['name'] as String,
        age: map['age'] as int,
        email: map['email'] as String,
        status: map['status'] as String,
      );
    } catch (e) {
      throw OrmSerializationException(
        'Failed to deserialize User from map',
        type: 'User',
        cause: e is Exception ? e : Exception(e.toString()),
      );
    }
  }

  /// Creates a query builder for User.
  ///
  /// This method is used internally by Database.query<User>()
  /// to create type-safe query builders.
  static UserQueryBuilder createQueryBuilder(Database db) {
    return UserQueryBuilder._(db);
  }

  /// Relationship metadata for User
  static const relationshipMetadata = <String, Map<String, dynamic>>{
    'profile': {
      'fieldName': 'profile',
      'targetType': 'Profile',
      'isList': false,
      'isOptional': true,
      'type': 'RecordLink',
      'effectiveTableName': 'profile',
    },
    'posts': {
      'fieldName': 'posts',
      'targetType': 'Post',
      'isList': true,
      'isOptional': true,
      'type': 'RecordLink',
      'effectiveTableName': 'post',
    },
  };
}

// Where Builder for User
/// Type-safe where condition builder for User entities.
///
/// This class provides field accessors that return condition builders
/// with type-safe operator methods.
///
/// Example:
/// ```dart
/// final users = await db.query<User>()
///   .where((t) => t.fieldName.equals(value))
///   .execute();
/// ```
class UserWhereBuilder {
  /// Condition builder for the name field.
  StringFieldCondition get name => StringFieldCondition('name');

  /// Condition builder for the age field.
  NumberFieldCondition<int> get age => NumberFieldCondition<int>('age');

  /// Condition builder for the email field.
  StringFieldCondition get email => StringFieldCondition('email');

  /// Condition builder for the status field.
  StringFieldCondition get status => StringFieldCondition('status');
}

// Query Builder for User
/// Type-safe query builder for User entities.
///
/// This class provides a fluent API for building queries against
/// the users table with compile-time type safety.
///
/// Example:
/// ```dart
/// final results = await db.query<User>()
///   .where((t) => t.field.equals(value))
///   .limit(10)
///   .orderBy('name', ascending: true)
///   .execute();
/// ```
class UserQueryBuilder {
  final Database _db;
  int? _limit;
  int? _offset;
  String? _orderByField;
  bool _orderByAscending = true;
  WhereCondition? _whereCondition;
  final Map<String, dynamic> _legacyWhereConditions = {};

  /// Private constructor - use Database.query<User>() instead.
  UserQueryBuilder._(this._db);

  /// Adds a where condition using the type-safe where builder.
  ///
  /// Example:
  /// ```dart
  /// .where((t) => t.age.greaterThan(18) & t.status.equals('active'))
  /// ```
  UserQueryBuilder where(WhereCondition Function(UserWhereBuilder) builder) {
    final whereBuilder = UserWhereBuilder();
    _whereCondition = builder(whereBuilder);
    return this;
  }

  /// Sets the maximum number of results to return.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  UserQueryBuilder limit(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Limit must be non-negative');
    }
    _limit = count;
    return this;
  }

  /// Sets the number of results to skip before returning.
  ///
  /// Throws [ArgumentError] if [count] is negative.
  UserQueryBuilder offset(int count) {
    if (count < 0) {
      throw ArgumentError.value(count, 'count', 'Offset must be non-negative');
    }
    _offset = count;
    return this;
  }

  /// Sets the field to order results by.
  ///
  /// Parameters:
  /// - [field]: The field name to sort by
  /// - [ascending]: Sort direction (default: true)
  UserQueryBuilder orderBy(String field, {bool ascending = true}) {
    _orderByField = field;
    _orderByAscending = ascending;
    return this;
  }

  /// Adds an equals condition for the name field (legacy method).
  ///
  /// Consider using .where((t) => t.name.equals(value)) instead.
  UserQueryBuilder whereNameEquals(String value) {
    _legacyWhereConditions['name'] = value;
    return this;
  }

  /// Adds an equals condition for the age field (legacy method).
  ///
  /// Consider using .where((t) => t.age.equals(value)) instead.
  UserQueryBuilder whereAgeEquals(int value) {
    _legacyWhereConditions['age'] = value;
    return this;
  }

  /// Adds an equals condition for the email field (legacy method).
  ///
  /// Consider using .where((t) => t.email.equals(value)) instead.
  UserQueryBuilder whereEmailEquals(String value) {
    _legacyWhereConditions['email'] = value;
    return this;
  }

  /// Adds an equals condition for the status field (legacy method).
  ///
  /// Consider using .where((t) => t.status.equals(value)) instead.
  UserQueryBuilder whereStatusEquals(String value) {
    _legacyWhereConditions['status'] = value;
    return this;
  }

  /// Executes the query and returns the results.
  ///
  /// Returns a list of User instances matching the query criteria.
  ///
  /// Throws [QueryException] if the query fails.
  Future<List<User>> execute() async {
    // Build SELECT query
    final buffer = StringBuffer('SELECT * FROM users');

    // Add WHERE clauses
    final whereClauses = <String>[];

    // Add type-safe where condition
    if (_whereCondition != null) {
      whereClauses.add(_whereCondition!.toSurrealQL(_db));
    }

    // Add legacy where conditions
    if (_legacyWhereConditions.isNotEmpty) {
      for (final entry in _legacyWhereConditions.entries) {
        final paramName = 'param_${entry.key}';
        await _db.set(paramName, entry.value);
        whereClauses.add('${entry.key} = \$$paramName');
      }
    }

    if (whereClauses.isNotEmpty) {
      buffer.write(' WHERE ');
      buffer.write(whereClauses.join(' AND '));
    }

    // Add ORDER BY clause
    if (_orderByField != null) {
      buffer.write(' ORDER BY $_orderByField');
      buffer.write(_orderByAscending ? ' ASC' : ' DESC');
    }

    // Add LIMIT clause
    if (_limit != null) {
      buffer.write(' LIMIT $_limit');
    }

    // Add OFFSET/START clause
    if (_offset != null) {
      buffer.write(' START $_offset');
    }

    // Execute query
    final response = await _db.queryQL(buffer.toString());
    final results = response.getResults();

    // Deserialize results
    return results.map((map) => UserORM.fromSurrealMap(map)).toList();
  }

  /// Executes the query and returns the first result, or null if no results.
  ///
  /// This is a convenience method equivalent to `.limit(1).execute()`
  /// followed by returning the first element or null.
  Future<User?> first() async {
    final results = await limit(1).execute();
    return results.isEmpty ? null : results.first;
  }
}
