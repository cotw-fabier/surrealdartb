# Task 2.3: Get Operation

## Overview
**Task Reference:** Task #2.3 from `agent-os/specs/2025-10-21-sdk-parity/tasks.md`
**Implemented By:** api-engineer
**Date:** 2025-10-21
**Status:** ✅ Complete

### Task Description
Implement the `get` operation for the SurrealDB Dart SDK to retrieve a single record by its resource identifier (table:id format). Unlike other CRUD operations, get returns null for non-existent records rather than throwing an exception, providing a more user-friendly API for checking record existence.

## Implementation Summary
The get operation was implemented following the existing FFI patterns in the codebase. The implementation consists of three layers:

1. **Rust FFI Layer** (`db_get` function in `rust/src/query.rs`): Executes a SELECT query for a specific resource identifier, handling both existing and non-existent records gracefully.

2. **Dart FFI Bindings** (`dbGet` function in `lib/src/ffi/bindings.dart`): Direct FFI binding to the Rust function with proper type annotations.

3. **High-Level API** (`get<T>` method in `lib/src/database.dart`): User-facing generic method that returns nullable typed results with automatic JSON deserialization.

The implementation strictly follows the patterns established by existing CRUD operations (`select`, `create`, `update`, `delete`) to maintain consistency throughout the codebase.

## Files Changed/Created

### New Files
- `test/unit/get_operation_test.dart` - Comprehensive test suite for get operation with 6 focused tests covering all critical paths

### Modified Files
- `rust/src/query.rs` - Added `db_get` FFI function (lines 911-1002)
- `rust/src/lib.rs` - Exported `db_get` function in module exports (line 46)
- `lib/src/ffi/bindings.dart` - Added `dbGet` FFI binding declaration (lines 206-217)
- `lib/src/ffi/native_types.dart` - Added `NativeDbGet` typedef for FFI signature (lines 98-105)
- `lib/src/database.dart` - Implemented public `get<T>` method (lines 504-565)

### Deleted Files
None

## Key Implementation Details

### Rust FFI Function (`db_get`)
**Location:** `rust/src/query.rs` (lines 911-1002)

The Rust implementation uses the same query execution pattern as other CRUD operations:
- Validates input parameters (null checks for handle and resource)
- Validates resource string is not empty
- Executes `SELECT * FROM {resource}` query via SurrealDB's query API
- Uses the existing `surreal_value_to_json` unwrapper to convert SurrealDB values to clean JSON
- Returns empty array structure `[[]]` for non-existent records (not an error)
- Wraps everything in `panic::catch_unwind` for FFI safety

**Rationale:** Using SELECT rather than a dedicated get API ensures consistent response structure with other query operations. The manual value unwrapper prevents type wrapper pollution in JSON responses.

### Dart FFI Binding (`dbGet`)
**Location:** `lib/src/ffi/bindings.dart` (lines 206-217)

Direct FFI binding using Dart 3.0's `@Native` annotation:
```dart
@Native<NativeDbGet>(symbol: 'db_get', assetId: 'package:surrealdartb/surrealdartb_bindings')
external Pointer<NativeResponse> dbGet(
  Pointer<NativeDatabase> handle,
  Pointer<Utf8> resource,
);
```

**Rationale:** Follows the exact same pattern as `dbSelect`, `dbCreate`, `dbUpdate`, and `dbDelete` for consistency.

### High-Level API (`get<T>`)
**Location:** `lib/src/database.dart` (lines 504-565)

Generic method with nullable return type:
```dart
Future<T?> get<T>(String resource) async
```

Key features:
- Wraps FFI call in `Future(() {...})` for consistent async behavior
- Uses `_processResponse()` to extract and deserialize JSON
- Unwraps nested array structure: `[[{record}]]` → `{record}` or `[[]]` → `null`
- Memory cleanup in `finally` block via `malloc.free(resourcePtr)`
- Returns null for non-existent records (not an exception)

**Rationale:** The nullable return type (`T?`) provides a more ergonomic API than throwing exceptions for missing records, allowing users to use null-checking operators like `?.` and `??` naturally.

## Database Changes
No database schema changes were required. This operation only reads existing data.

## Dependencies

### New Dependencies Added
None. The implementation uses existing dependencies already in the project.

### Configuration Changes
None. No environment variables or configuration files were modified.

## Testing

### Test Files Created/Updated
- `test/unit/get_operation_test.dart` - New test file with 6 focused tests

### Test Coverage
- Unit tests: ✅ Complete
- Integration tests: ⚠️ Partial (covered by existing integration tests)
- Edge cases covered:
  - Get existing record returns correct data
  - Get non-existent record returns null
  - Get from non-existent table returns null
  - Generic type deserialization works correctly
  - Invalid resource format throws exception
  - Complex nested data is preserved

### Manual Testing Performed
1. Ran `dart test test/unit/get_operation_test.dart` - All 6 tests passed
2. Verified Rust compilation succeeded: `cargo build --release` in rust/ directory
3. Tested with both memory and RocksDB backends (via test setup)
4. Verified memory cleanup by checking no leaks during repeated test runs

### Test Results
```
00:04 +6: All tests passed!
```

All 6 tests in the get operation test suite passed successfully:
- ✅ Get existing record returns typed result
- ✅ Get non-existent record returns null
- ✅ Get from non-existent table returns null
- ✅ Generic type deserialization works
- ✅ Invalid resource format throws exception
- ✅ Complex nested data preserved

## User Standards & Preferences Compliance

### Coding Style (agent-os/standards/global/coding-style.md)
**How Implementation Complies:**
The implementation strictly adheres to Dart coding conventions: method names use camelCase (`get`), the method is properly documented with dartdoc comments including examples, and code structure mirrors existing patterns in database.dart for consistency.

**Deviations:** None

### Commenting (agent-os/standards/global/commenting.md)
**How Implementation Complies:**
All public API methods include comprehensive dartdoc comments with parameter descriptions, return value documentation, exception documentation, and usage examples. The Rust code includes detailed inline comments explaining the SELECT query approach and null handling strategy.

**Deviations:** None

### Error Handling (agent-os/standards/global/error-handling.md)
**How Implementation Complies:**
The implementation uses the established exception hierarchy (`DatabaseException` for invalid parameters, `QueryException` for execution failures). Memory cleanup is guaranteed via try/finally blocks. The Rust layer uses `panic::catch_unwind` to prevent panics from crossing the FFI boundary. Invalid resource parameters trigger appropriate exceptions rather than silent failures.

**Deviations:** None

### Native Bindings (agent-os/standards/backend/native-bindings.md)
**How Implementation Complies:**
The FFI function uses `@Native` annotation with symbol and assetId, pointer types are properly managed with malloc.free() in finally blocks, and the implementation follows the opaque handle pattern for NativeDatabase and NativeResponse. CString/CStr is used for string passing between Rust and Dart.

**Deviations:** None

### Rust Integration (agent-os/standards/backend/rust-integration.md)
**How Implementation Complies:**
The Rust function is marked with `#[no_mangle]` and `extern "C"`, uses `panic::catch_unwind` for all FFI entry points, validates all input parameters before use (null checks, empty string validation), and uses the thread-local error storage pattern via `set_last_error` for error messages.

**Deviations:** None

### Async Patterns (agent-os/standards/backend/async-patterns.md)
**How Implementation Complies:**
The Rust layer uses `runtime.block_on()` to handle SurrealDB's async operations synchronously within the FFI boundary. The Dart layer wraps the synchronous FFI call in `Future(() {...})` to maintain the async API contract. This matches the pattern used by all other database operations.

**Deviations:** None

### Test Writing (agent-os/standards/testing/test-writing.md)
**How Implementation Complies:**
The test file is organized with a test group (`Database.get()`), uses proper setup/tearDown for database lifecycle management, tests both success and failure paths, and focuses on critical scenarios rather than exhaustive edge case testing. Each test is focused on a single behavior and has a clear descriptive name.

**Deviations:** None

## Integration Points

### APIs/Endpoints
- `Future<T?> get<T>(String resource)` - Public API method for retrieving a single record
  - Request format: Resource identifier string (e.g., "person:alice")
  - Response format: Deserialized record as type T, or null if not found

### External Services
None. This operation only interacts with the local embedded SurrealDB instance.

### Internal Dependencies
- Depends on FFI bindings layer (`lib/src/ffi/bindings.dart`, `lib/src/ffi/native_types.dart`)
- Uses common response processing logic (`_processResponse()` in database.dart)
- Relies on Rust query execution infrastructure (`rust/src/query.rs`)
- Uses SurrealDB's query API for record retrieval

## Known Issues & Limitations

### Issues
None identified. All tests pass and functionality works as expected.

### Limitations
1. **Resource Format Validation**
   - Description: The method accepts any string format and relies on Rust/SurrealDB to validate the resource identifier
   - Reason: Keeping validation logic in the Rust layer maintains consistency with other operations and avoids duplicating validation logic
   - Future Consideration: Could add client-side validation for better error messages, but current approach is sufficient

2. **Type Safety**
   - Description: The generic type parameter T is not validated against the actual record structure
   - Reason: Dart's type system doesn't provide runtime type checking for generics; this is consistent with other generic methods like select<T>
   - Future Consideration: Could add optional JSON schema validation in future iterations

3. **Embedded Mode Only**
   - Description: Implementation is for embedded SurrealDB only (memory and RocksDB backends)
   - Reason: Spec focuses on SDK parity for embedded mode; remote server support is deferred
   - Future Consideration: Remote server support can be added in future iterations following similar patterns

## Performance Considerations
The get operation uses SELECT queries internally, which are optimized by SurrealDB for single record retrieval. The FFI overhead is minimal due to direct function calls without isolate boundaries. Memory allocation for string parameters is short-lived and cleaned up immediately via try/finally blocks.

For non-existent records, the operation returns quickly with an empty result set rather than throwing exceptions, avoiding the performance cost of exception handling.

## Security Considerations
- The resource parameter is passed as-is to SurrealDB without sanitization, relying on SurrealDB's query parser to handle malicious input safely
- The Rust layer performs null pointer checks and empty string validation before accessing memory
- The FFI boundary is protected by `panic::catch_unwind` to prevent undefined behavior from Rust panics
- No sensitive data is logged or exposed in error messages beyond what SurrealDB already reports

## Dependencies for Other Tasks
- **Task Group 2.1 (Insert Operations)**: No direct dependency, but insert will create records that can be retrieved via get
- **Task Group 2.2 (Upsert Operations)**: No direct dependency, but upsert will create/update records that can be retrieved via get
- **Task Group 6.1 (Live Queries)**: Live query notifications may include record IDs that users will want to retrieve via get

## Notes
- The implementation intentionally returns null for non-existent records rather than throwing exceptions, providing a more ergonomic API for existence checks
- The nested array unwrapping logic (`[[{record}]]` → `{record}`) matches the pattern used by other CRUD operations for consistency
- The Rust implementation uses SELECT rather than a hypothetical native "get" method to leverage existing query infrastructure and ensure consistent behavior
- All memory management follows the try/finally pattern established in the codebase, with resource cleanup guaranteed even in error paths
- The generic type parameter T allows type-safe deserialization while maintaining flexibility for different record structures
