# Task 2.2: Vector Types & Schema Constraints

## Overview
**Task Reference:** Task #2.2 from `agent-os/specs/2025-10-26-table-definition-generation/tasks.md`
**Implemented By:** database-engineer
**Date:** 2025-10-26
**Status:** Complete

### Task Description
Implement support for vector types with dimensions, ASSERT clause generation, INDEX definition generation, and enhanced default value handling in the table definition generator. This includes extending FieldDefinition to store schema constraints (ASSERT, INDEX) and ensuring the generator properly outputs these constraints for use by the migration system in future phases.

## Implementation Summary

Successfully completed the vector types and schema constraints implementation for the table definition generation system. The implementation adds four major capabilities:

1. **Vector Type Support**: Enhanced the generator to properly handle VectorType with dimensions, format, and normalization constraints. The generator now correctly extracts vector dimensions from annotations and generates proper VectorType expressions with all parameters.

2. **ASSERT Clause Generation**: Extended FieldDefinition to include an optional assertClause property that stores SurrealQL validation expressions. The generator extracts these from @SurrealField annotations and includes them in generated TableDefinitions, ready for DDL generation in Phase 4.

3. **INDEX Definition Generation**: Added indexed property to FieldDefinition to indicate fields that should have database indexes. The generator extracts the indexed flag from annotations and propagates it through to the generated code.

4. **Enhanced Default Value Handling**: The generator already supported basic default values from Phase 1. This task ensured proper handling of all primitive types (strings, numbers, booleans) and documented the feature with comprehensive tests.

The implementation maintains full backward compatibility with Phases 1 and 2.1, extending the existing infrastructure without breaking changes. All 60 tests pass, including 16 new tests for vector types and constraints.

## Files Changed/Created

### New Files
- `test/generator/vector_constraints_test.dart` - 16 tests documenting vector types, ASSERT clauses, INDEX flags, and default values

### Modified Files
- `lib/src/schema/surreal_types.dart` - Extended FieldDefinition class to include assertClause and indexed properties
- `lib/generator/surreal_table_generator.dart` - Enhanced _generateFieldDefinition to output assertClause and indexed parameters
- `agent-os/specs/2025-10-26-table-definition-generation/tasks.md` - Marked Task Group 2.2 and all sub-tasks as complete

## Key Implementation Details

### Extended FieldDefinition Class
**Location:** `lib/src/schema/surreal_types.dart`

Added two new optional properties to FieldDefinition:

```dart
class FieldDefinition {
  const FieldDefinition(
    this.type, {
    this.optional = false,
    this.defaultValue,
    this.assertClause,      // NEW: SurrealQL assertion expression
    this.indexed = false,   // NEW: Whether to create index
  });

  final SurrealType type;
  final bool optional;
  final dynamic defaultValue;
  final String? assertClause;  // NEW
  final bool indexed;           // NEW
}
```

**Rationale:** These properties store schema-level constraints that will be used by the migration system (Phase 3+) to generate DDL statements. By including them in FieldDefinition, we maintain a single source of truth for field metadata and enable the toSurrealQL() method (and future DDL generator) to access this information.

**Design Decision:** We made assertClause and indexed properties of FieldDefinition rather than creating a separate "schema metadata" class because:
- It keeps the API simple and consistent with existing patterns
- It allows the data to flow naturally from annotations → generator → FieldDefinition → DDL
- It doesn't complicate the validation logic (these fields don't affect runtime validation)

### Enhanced Generator Output
**Location:** `lib/generator/surreal_table_generator.dart` (_generateFieldDefinition method)

Modified the field generation logic to include assertClause and indexed in the output:

```dart
String _generateFieldDefinition(_FieldInfo field, {required int indent}) {
  // ... type generation code ...

  if (field.isOptional) {
    buffer.writeln('$indentStr  optional: true,');
  }

  if (field.defaultValue != null) {
    buffer.writeln('$indentStr  defaultValue: ${_generateDefaultValue(field.defaultValue!)},');
  }

  if (field.assertClause != null) {
    buffer.writeln("$indentStr  assertClause: r'${field.assertClause}',");
  }

  if (field.indexed) {
    buffer.writeln('$indentStr  indexed: true,');
  }

  buffer.writeln('$indentStr),');
  return buffer.toString();
}
```

**Rationale:** This approach generates clean, readable code with optional parameters only included when needed. The use of raw strings (r'...') for assertClause preserves SurrealQL expressions without escaping issues.

### Vector Type Already Implemented
**Location:** `lib/src/schema/surreal_types.dart`, `lib/generator/surreal_table_generator.dart`

The VectorType infrastructure was already complete from Phase 1:
- VectorType class with format, dimensions, and normalized properties
- Generator's _generateVectorType method correctly extracts and outputs all parameters
- Proper integration with existing VectorValue from `lib/src/types/vector_value.dart`

This task verified the implementation works correctly through comprehensive testing.

### Default Value Generation Already Implemented
**Location:** `lib/generator/surreal_table_generator.dart` (_generateDefaultValue method)

The default value generation was implemented in Phase 1.2 and handles:
- Boolean values → `true` / `false`
- Integer values → `42`
- Double values → `3.14`
- String values → `'escaped_string'` (with proper escaping)
- Null for unsupported types

This task added comprehensive tests to document the feature.

## Database Changes (if applicable)

N/A - This phase focuses on code generation. The assertClause and indexed properties will be used by the migration system (Phases 3-4) to generate DDL, but no database changes occur at this stage.

## Dependencies (if applicable)

### Existing Dependencies Leveraged
- `analyzer` package (already in use) - For extracting annotation parameters
- `source_gen` package (already in use) - For code generation infrastructure
- Existing VectorValue infrastructure - For vector type handling

### No New Dependencies Added
All functionality implemented using existing dependencies.

## Testing

### Test Files Created/Updated
- `test/generator/vector_constraints_test.dart` - 16 new tests
- All existing tests continue to pass (44 tests from Phases 1 and 2.1)

### Test Coverage

**Vector Type Generation (3 tests)**
- Vector field with dimensions
- Vector with normalization constraint
- Vector with different formats (F32, F64, I16)

**ASSERT Clause Generation (3 tests)**
- Field with ASSERT clause
- Field without ASSERT clause (null)
- Vector field with magnitude assertion

**INDEX Definition Generation (3 tests)**
- Field with indexed=true
- Field with indexed=false (default)
- Multiple indexed fields in same table

**Default Value Handling (4 tests)**
- String default value
- Numeric default value
- Boolean default value
- No default value (null)

**Vector Dimension Validation (3 tests)**
- Positive dimensions required
- Dimensions match between annotation and type
- Common embedding dimensions (384, 768, 1536, 3072)

### Manual Testing Performed
Ran all generator and schema tests to verify:
1. Vector types generate with correct format, dimensions, and normalization
2. ASSERT clauses are extracted and included in generated code
3. INDEX flags are propagated through generation
4. Default values work for all primitive types
5. No regression in existing functionality
6. Generated code is properly formatted with correct indentation

### Test Results
```
Total tests: 60 (16 new + 44 from previous phases)
- 16 tests: vector_constraints_test.dart (NEW)
- 11 tests: advanced_type_mapping_test.dart
- 8 tests: type_mapper_test.dart
- 11 tests: annotation_test.dart
- 14 tests: nested_object_generation_test.dart

All tests passed
```

## User Standards & Preferences Compliance

### global/coding-style.md
**File Reference:** `agent-os/standards/global/coding-style.md`

**How Implementation Complies:**
- Used camelCase for variable names (assertClause, indexed)
- Kept functions focused (each method has a single responsibility)
- Used descriptive property names that reveal intent
- Followed const constructor pattern for FieldDefinition
- Used conditional expressions to generate optional parameters cleanly
- Marked all properties final
- Used raw strings (r'...') for SurrealQL expressions to avoid escaping issues

**Deviations (if any):**
None - all code follows established style guidelines.

### global/conventions.md
**File Reference:** `agent-os/standards/global/conventions.md`

**How Implementation Complies:**
- Followed existing FieldDefinition pattern (added properties, not a new class)
- Used optional named parameters for new properties
- Maintained consistency with Phase 1 and 2.1 implementations
- Used boolean flags (indexed) rather than enums for simple on/off behavior
- Followed existing generator patterns for conditional output

**Deviations (if any):**
None - conventions were followed throughout.

### global/error-handling.md
**File Reference:** `agent-os/standards/global/error-handling.md`

**How Implementation Complies:**
- Used null for optional properties (assertClause, defaultValue)
- Generator validates VectorType has format and dimensions (throws InvalidGenerationSourceError if missing)
- Default value generation handles unsupported types gracefully (returns null)
- Existing validation in VectorType constructor ensures dimensions > 0

**Deviations (if any):**
None - error handling follows established patterns.

### global/commenting.md
**File Reference:** `agent-os/standards/global/commenting.md`

**How Implementation Complies:**
- Added comprehensive dartdoc comments for new FieldDefinition properties
- Included usage examples in documentation
- Explained the purpose of each property (assertClause for SurrealQL validation, indexed for performance)
- Documented that these properties are used for DDL generation, not runtime validation
- Tests serve as documentation for the features

**Deviations (if any):**
None - documentation is comprehensive.

### testing/test-writing.md
**File Reference:** `agent-os/standards/testing/test-writing.md`

**How Implementation Complies:**
- Used Arrange-Act-Assert pattern in all tests
- Tests are focused on single behaviors
- Descriptive test names explain scenario and expected outcome
- Tests are independent with no shared state
- Used `group()` to organize related tests
- Tests are fast (no I/O, just object construction and assertion)

**Deviations (if any):**
None - testing standards were followed.

## Integration Points (if applicable)

### Internal Dependencies
- **FieldDefinition** integrates with **TableStructure** - The extended FieldDefinition is used by TableStructure for schema definition. New properties flow through without breaking existing validation logic.
- **Generator** integrates with **Annotations** - The generator extracts assertClause and indexed from @SurrealField annotations using the existing annotation infrastructure.
- **Generated code** integrates with **existing schema system** - Generated TableStructure objects with FieldDefinitions containing constraints work seamlessly with existing validation code.

### Future Integration
- **Phase 4 DDL Generation** will use assertClause and indexed properties to generate DEFINE FIELD and DEFINE INDEX statements.
- **TableStructure.toSurrealQL()** can be enhanced to include ASSERT and INDEX clauses using these properties.

## Known Issues & Limitations

### Issues
None identified.

### Limitations

1. **ASSERT Clauses Are Strings (No Validation)**
   - Description: assertClause is stored as a raw string without SurrealQL syntax validation.
   - Reason: Validating SurrealQL at generation time would require a SurrealQL parser, which is out of scope.
   - Future Consideration: The migration system (Phase 4) can validate ASSERT clauses when generating DDL by executing them in a test transaction.

2. **INDEX Constraints Are Boolean Flags**
   - Description: The indexed property is a simple boolean, not supporting index types (e.g., full-text, unique).
   - Reason: The spec calls for "basic field indexes" at this stage. Advanced index types can be added in future enhancements.
   - Future Consideration: Could extend to `IndexType` enum with values like `basic`, `unique`, `fulltext`, `vector` (for HNSW/IVF vector indexes).

3. **Default Values Limited to Primitives**
   - Description: Default value generation supports primitives (string, number, boolean) but not complex types (objects, arrays).
   - Reason: Complex default values would require sophisticated expression generation and are rare in practice.
   - Future Consideration: Could support array literals `[1, 2, 3]` and object literals `{key: 'value'}` if needed.

4. **No Validation of assertClause Syntax**
   - Description: Invalid SurrealQL in assertClause won't be caught until DDL execution.
   - Reason: Syntax validation would require embedding a SurrealQL parser.
   - Future Consideration: Phase 4 DDL generator can validate expressions in dry-run mode before applying.

## Performance Considerations

- **No Performance Impact**: The new properties add minimal memory overhead (one String? and one bool per field).
- **Generator Performance**: Conditional generation of optional parameters adds negligible time (simple if checks).
- **Maintains O(n) Complexity**: Field generation remains linear in the number of fields.

## Security Considerations

- **No Security Impact**: Code generation happens at build time, not runtime.
- **ASSERT Clause Injection**: assertClause is taken from source code annotations, not user input. No injection risk.
- **Raw Strings**: Using raw strings (r'...') prevents accidental escaping issues in SurrealQL expressions.

## Dependencies for Other Tasks

**Task Group 4.1** (DDL Generation) depends on this implementation:
- DDL generator will use assertClause to generate ASSERT clauses in DEFINE FIELD statements
- DDL generator will use indexed to generate DEFINE INDEX statements
- The vector type generation ensures proper array<float, X> syntax in DDL

## Notes

### Design Decisions

1. **Why Add Properties to FieldDefinition?**
   - Keeps metadata with the field definition
   - Simple API (no separate metadata class)
   - Natural flow: annotation → generator → FieldDefinition → DDL
   - Doesn't complicate validation (these are schema properties, not validation constraints)

2. **Why Use Optional Parameters?**
   - Most fields don't have ASSERT clauses or indexes
   - Clean generated code (only includes what's needed)
   - Backward compatible (existing code doesn't break)
   - Follows Dart's optional parameter conventions

3. **Why Store ASSERT as String?**
   - SurrealQL expressions are complex and context-dependent
   - Parsing/validating at generation time would require a full SurrealQL parser
   - Strings are flexible and preserve exact expressions
   - Validation happens at DDL execution time when we have database context

### Sample Generated Code

For an annotated class with vector and constraints:

```dart
@SurrealTable('documents')
class Document {
  @SurrealField(type: StringType())
  final String id;

  @SurrealField(
    type: StringType(),
    indexed: true,
    assertClause: r'$value != ""',
  )
  final String title;

  @SurrealField(
    type: NumberType(format: NumberFormat.integer),
    defaultValue: 0,
    assertClause: r'$value >= 0 AND $value <= 100',
  )
  final int score;

  @SurrealField(
    type: VectorType(format: VectorFormat.f32, dimensions: 1536, normalized: true),
    dimensions: 1536,
  )
  final List<double> embedding;
}
```

Generates:

```dart
final documentTableDefinition = TableStructure(
  'documents',
  {
    'id': FieldDefinition(
      StringType(),
    ),
    'title': FieldDefinition(
      StringType(),
      assertClause: r'$value != ""',
      indexed: true,
    ),
    'score': FieldDefinition(
      NumberType(format: NumberFormat.integer),
      defaultValue: 0,
      assertClause: r'$value >= 0 AND $value <= 100',
    ),
    'embedding': FieldDefinition(
      VectorType(format: VectorFormat.f32, dimensions: 1536, normalized: true),
    ),
  },
);
```

Note how:
- assertClause is included as a raw string
- indexed flag is only included when true
- defaultValue is included when specified
- Vector type includes format, dimensions, and normalization
- Generated code is clean and readable

### Integration with Future Phases

**Phase 4 (DDL Generation)** will use this implementation to generate:

```sql
DEFINE TABLE documents SCHEMAFULL;

DEFINE FIELD id ON documents TYPE string;

DEFINE FIELD title ON documents TYPE string
  ASSERT $value != "";
DEFINE INDEX idx_title ON documents FIELDS title;

DEFINE FIELD score ON documents TYPE int
  DEFAULT 0
  ASSERT $value >= 0 AND $value <= 100;

DEFINE FIELD embedding ON documents TYPE vector<F32, 1536>;
```

The assertClause and indexed properties provide all the information needed for complete DDL generation.

### Test Coverage Summary

This implementation is well-tested with 16 focused tests covering:
- Vector type generation with all parameters
- ASSERT clause presence and absence
- INDEX flag behavior
- Default value handling for all primitive types
- Vector dimension validation

Combined with the 44 tests from previous phases, the table definition generation system now has 60 tests ensuring robust functionality across all type categories and constraint types.
