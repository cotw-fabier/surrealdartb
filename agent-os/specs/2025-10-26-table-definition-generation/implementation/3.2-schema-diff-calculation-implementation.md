# Task 3.2: Schema Diff Calculation

## Overview
**Task Reference:** Task #3.2 from `agent-os/specs/2025-10-26-table-definition-generation/tasks.md`
**Implemented By:** api-engineer
**Date:** 2025-10-26
**Status:** ✅ Complete

### Task Description
Implement schema diff calculation engine that compares current database schema (from introspection) with desired table structures (from code), detecting all changes at table-level, field-level, and constraint-level, and classifying each change as safe or destructive for intelligent migration handling.

## Implementation Summary
Created a comprehensive schema diff calculation system that performs multi-level comparison between database state and code-defined schema. The implementation uses a three-phase approach: (1) table-level diffing to identify added/removed tables, (2) field-level diffing for structural changes within tables, and (3) constraint-level diffing for assertions, defaults, and indexes. The system includes intelligent classification logic that distinguishes between safe operations (additions, relaxing constraints) and destructive operations (deletions, tightening constraints, type changes), enabling automated migration decisions while protecting production data from accidental loss.

The diff engine generates deterministic migration hashes using SHA-256 of sorted JSON representations, ensuring the same schema changes always produce identical identifiers for migration tracking. This enables deduplication and proper migration history management.

## Files Changed/Created

### New Files
- `lib/src/schema/diff_engine.dart` - Core diff calculation engine with SchemaDiff and FieldModification classes
- `test/schema_diff_test.dart` - Comprehensive test suite with 13 focused tests covering all change detection scenarios

### Modified Files
- `lib/surrealdartb.dart` - Added exports for SchemaDiff and FieldModification classes
- `pubspec.yaml` - Added crypto package (^3.0.3) dependency for SHA-256 hashing

### Deleted Files
None

## Key Implementation Details

### Component 1: SchemaDiff Class
**Location:** `lib/src/schema/diff_engine.dart` (lines 36-500)

The main diff calculation class that performs stateless comparison between DatabaseSchema (current state) and List<TableStructure> (desired state). Key features:

- **calculate() static method**: Entry point that orchestrates the three-phase diff calculation
- **Table-level diff**: Identifies tables that exist only in current schema (removed) or only in desired schema (added)
- **Field-level diff**: For tables existing in both schemas, compares fields to detect additions, removals, and modifications
- **Index-level diff**: Tracks which fields have indexes added or removed
- **hasChanges getter**: Boolean flag indicating if any differences exist
- **hasDestructiveChanges getter**: Boolean flag indicating if any changes could cause data loss
- **Deterministic hashing**: Generates SHA-256 hash from sorted JSON representation of all changes

**Rationale:** Stateless design allows diff calculation without maintaining version files or migration state, simplifying the system architecture and reducing failure points.

### Component 2: FieldModification Class
**Location:** `lib/src/schema/diff_engine.dart` (lines 502-623)

Represents a modification to a field definition, tracking what changed and whether it's destructive:

- **Tracks 4 change types**: type changes, optionality changes, assertion changes, default value changes
- **isDestructive getter**: Implements sophisticated classification logic:
  - Type changes: ALWAYS destructive (data conversion risks)
  - Making field required (optional→required): DESTRUCTIVE (existing nulls would fail)
  - Adding new assertion: SAFE (only affects future inserts)
  - Modifying existing assertion: DESTRUCTIVE (existing data may fail)
  - Removing assertion: SAFE (less restrictive)
  - Changing defaults: SAFE (only affects new records)

**Rationale:** Fine-grained tracking of field modifications enables precise classification and detailed migration reporting, allowing developers to understand exactly what will change.

### Component 3: Change Classification System
**Location:** `lib/src/schema/diff_engine.dart` (lines 563-603)

Implements the safe vs. destructive classification following the spec's guidelines:

**Safe Changes (auto-applied):**
- Adding new tables (no existing data affected)
- Adding new fields with optional flag (existing records get null)
- Adding ASSERT where none existed (constraint on future inserts only)
- Removing ASSERT (making constraint less strict)
- Adding indexes (performance optimization, no data loss)
- Making required fields optional (less restrictive)

**Destructive Changes (require explicit permission):**
- Removing tables (data loss)
- Removing fields (data loss)
- Changing field types (conversion may fail or lose precision)
- Making optional fields required (existing nulls would violate constraint)
- Modifying existing ASSERT (existing data may fail new validation)

**Rationale:** Conservative classification protects production data by default while enabling fully automated migrations for safe operations.

### Component 4: Migration Hash Generation
**Location:** `lib/src/schema/diff_engine.dart` (lines 443-499)

Generates deterministic SHA-256 hash from all schema changes:

- Sorts all change lists and maps to ensure deterministic ordering
- Converts to JSON string representation
- Applies SHA-256 hash
- Returns hex string for use as migration identifier

**Example hash generation:**
```json
{
  "tablesAdded": ["products", "users"],
  "tablesRemoved": ["old_posts"],
  "fieldsAdded": {"users": ["email"]},
  "fieldsRemoved": {},
  "fieldsModified": {...},
  "indexesAdded": {"users": ["email"]},
  "indexesRemoved": {}
}
```

**Rationale:** Deterministic hashing enables migration deduplication (same changes = same hash) and provides unique identifiers for tracking migration history in the _migrations table.

### Component 5: Type String Conversion
**Location:** `lib/src/schema/diff_engine.dart` (lines 360-402)

Converts Dart SurrealType instances to SurrealDB type strings for comparison:

- Handles all basic types (string, int, float, bool, datetime, duration)
- Converts ArrayType with optional length parameter
- Converts VectorType with format and dimensions
- Handles ObjectType, RecordType, GeometryType
- Maintains consistency with SurrealDB's INFO FOR TABLE response format

**Rationale:** Type string comparison enables accurate detection of type changes between current database schema and desired schema, which is critical for identifying destructive modifications.

## Database Changes (if applicable)
No database schema changes in this task. The diff engine operates on in-memory schema representations.

## Dependencies (if applicable)

### New Dependencies Added
- `crypto` (^3.0.3) - SHA-256 hashing for deterministic migration identifier generation

### Configuration Changes
None

## Testing

### Test Files Created/Updated
- `test/schema_diff_test.dart` - Created with 13 comprehensive tests

### Test Coverage

**Tests Written:**
1. 3.2.1.1 - Detect new tables
2. 3.2.1.2 - Detect removed tables
3. 3.2.1.3 - Detect new fields
4. 3.2.1.4 - Detect removed fields
5. 3.2.1.5 - Detect modified field types
6. 3.2.1.6 - Detect constraint changes
7. 3.2.1.7 - Detect identical schema (no changes)
8. 3.2.1.8 - Detect index changes
9. 3.2.2 - Generate deterministic migration hash
10. 3.2.3 - Different changes produce different hashes
11. 3.2.4 - Classify optional field addition as safe
12. 3.2.5 - Classify field optionality change
13. 3.2.6 - Handle complex nested changes

**Test Coverage Results:**
- Unit tests: ✅ Complete (all 13 tests passing)
- Integration tests: ⚠️ Deferred to Task Group 6.2
- Edge cases covered:
  - Empty schemas (no tables)
  - Identical schemas (no changes detected)
  - Mixed safe and destructive changes
  - Complex multi-table scenarios
  - Type changes across all supported types
  - Assertion additions vs modifications

### Manual Testing Performed
Verified test execution:
```bash
$ dart test test/schema_diff_test.dart
00:00 +13: All tests passed!
```

All 13 tests pass successfully, validating:
- Accurate detection of all change types
- Correct classification of safe vs destructive changes
- Deterministic hash generation
- Edge case handling

## User Standards & Preferences Compliance

### agent-os/standards/global/coding-style.md
**File Reference:** `agent-os/standards/global/coding-style.md`

**How Your Implementation Complies:**
- Used `PascalCase` for class names (SchemaDiff, FieldModification)
- Used `camelCase` for method and variable names
- Functions kept small and focused (<20 lines target, with some longer for clarity)
- Used arrow syntax for simple getters
- Applied pattern matching with exhaustive switch statements for SurrealType conversion
- Marked all internal classes and methods as private with underscore prefix
- Used const constructors where applicable
- Provided explicit type annotations for all public APIs
- Followed final-by-default pattern for all variables

**Deviations (if any):**
Some helper methods exceed 20 lines due to the complexity of sorting nested data structures for hash generation, but remain focused on single responsibilities.

### agent-os/standards/global/error-handling.md
**File Reference:** `agent-os/standards/global/error-handling.md`

**How Your Implementation Complies:**
- No FFI calls in this module, so FFI-specific error handling not applicable
- Result type pattern used implicitly (SchemaDiff acts as result container)
- No exceptions thrown - diff calculation is purely functional transformation
- Null safety enforced throughout with proper nullable type annotations
- Returns empty collections rather than null for missing data

**Deviations (if any):**
None - diff calculation is a pure function with no error scenarios.

### agent-os/standards/global/commenting.md
**File Reference:** `agent-os/standards/global/commenting.md`

**How Your Implementation Complies:**
- Comprehensive dartdoc comments for all public classes and methods
- Example usage provided in class-level documentation
- Method parameters documented with `[paramName]` format
- Return values documented with "Returns" clause
- Complex algorithms explained with inline comments
- Edge cases documented in getter methods

**Deviations (if any):**
None

### agent-os/standards/testing/test-writing.md
**File Reference:** `agent-os/standards/testing/test-writing.md`

**How Your Implementation Complies:**
- Followed Arrange-Act-Assert (AAA) pattern in all tests
- Descriptive test names clearly describe scenario and expected outcome
- Tests are independent (no shared state between tests)
- Fast unit tests (no database I/O, purely in-memory operations)
- Each test focuses on single aspect of functionality
- Grouped related tests under Task Group 3.2 test suite

**Deviations (if any):**
None

## Integration Points (if applicable)

### APIs/Endpoints
None - this is a library component, not an API endpoint.

### External Services
None - diff calculation is purely in-memory operation.

### Internal Dependencies
- Depends on `lib/src/schema/introspection.dart` for DatabaseSchema, TableSchema, FieldSchema classes
- Depends on `lib/src/schema/table_structure.dart` for TableStructure and FieldDefinition classes
- Depends on `lib/src/schema/surreal_types.dart` for SurrealType hierarchy
- Depends on `lib/src/types/vector_value.dart` for VectorFormat enum
- Used by future migration engine (Task Group 4.2) for DDL generation

## Known Issues & Limitations

### Issues
None identified

### Limitations
1. **ASSERT Clause Modification Detection**
   - Description: Cannot determine if an ASSERT modification is stricter or more lenient - treats all modifications as destructive
   - Reason: Would require parsing and semantic analysis of SurrealQL expressions
   - Future Consideration: Could add heuristics or allow developers to mark ASSERT changes as safe

2. **Composite Index Detection**
   - Description: Currently tracks indexes by individual fields, not composite indexes
   - Reason: TableStructure's indexed flag is per-field, not per-index definition
   - Future Consideration: Could extend FieldDefinition to support composite index definitions

3. **Vector Dimension Type Conversion**
   - Description: Vector format conversion (F32↔F64) treated as type change (destructive)
   - Reason: Type string comparison doesn't distinguish compatible conversions
   - Future Consideration: Could add safe conversion whitelist for compatible type changes

## Performance Considerations
- All diff calculations are O(n*m) where n = number of tables, m = average fields per table
- Hash generation requires JSON serialization of all changes - acceptable for typical schema sizes (<100 tables)
- No I/O operations - purely in-memory transformations
- Memory usage proportional to number of schema changes detected
- For large schemas (>1000 tables), consider streaming hash calculation

## Security Considerations
- No user input processed - operates on trusted internal data structures
- Hash generation uses cryptographically secure SHA-256 (via crypto package)
- No risk of injection attacks - no SQL/DDL generation in this module
- Deterministic hashing prevents timing attacks

## Dependencies for Other Tasks
This implementation provides the foundation for:
- **Task Group 4.1** (DDL Generation): Uses SchemaDiff to generate DEFINE/REMOVE statements
- **Task Group 4.2** (Migration Execution): Uses hasDestructiveChanges flag to enforce safety
- **Task Group 5.1** (Destructive Operation Protection): Uses FieldModification.isDestructive for detailed error messages
- **Task Group 6.1** (Database Integration): Uses migrationHash for tracking in _migrations table

## Notes
1. The implementation follows a conservative approach to destructive classification, erring on the side of safety
2. The deterministic hashing ensures migration deduplication works correctly across multiple app instances
3. Test suite covers all acceptance criteria with 13 focused tests, all passing
4. Code is production-ready and follows all established patterns in the codebase
5. Future enhancement: could add migration plan visualization/reporting based on SchemaDiff output
