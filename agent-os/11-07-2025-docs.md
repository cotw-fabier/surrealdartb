# SurrealDart Documentation Master Plan
**Date**: November 7, 2025
**Status**: In Progress

## Objective
Create comprehensive, production-ready documentation for the SurrealDart library that teaches developers how to use all major features through clear explanations and practical code examples.

## Documentation Location
All documentation will be created in: `docs/README.md`

## Documentation Sections & Assignments

### Section 1: Getting Started & Database Initialization
**Assigned to**: api-engineer
**Location in docs**: Top of README.md

**Requirements**:
- Brief introduction to SurrealDart library
- Installation instructions (adding to pubspec.yaml)
- Database initialization patterns:
  - In-memory database (for testing)
  - RocksDB persistent database (for production)
  - Connection parameters (backend, path, namespace, database)
- **Flutter Integration Guide** (IMPORTANT):
  - How to determine correct storage path for iOS (use `path_provider` package)
  - How to determine correct storage path for Android (use `path_provider` package)
  - Example code showing `getApplicationDocumentsDirectory()`
  - Best practices for database file naming and location
- Connection error handling (ConnectionException, QueryException, DatabaseException)
- Database lifecycle (when to open/close connections)
- Complete working examples for both memory and RocksDB backends

**Code Examples Needed**:
- Basic memory database connection
- RocksDB connection with path setup
- Flutter app integration with path_provider
- Error handling pattern
- Cleanup in finally block

### Section 2: Basic QL Functions Usage
**Assigned to**: api-engineer
**Location in docs**: After Getting Started section

**Requirements**:
- Introduction to QL methods as the basic API for SurrealDB operations
- CRUD operations with clear examples:
  - `createQL(table, data)` - Creating records
  - `selectQL(table)` - Reading all records
  - `get<T>(recordId)` - Getting specific record
  - `updateQL(recordId, data)` - Updating records
  - `deleteQL(recordId)` - Deleting records
- Raw query execution:
  - `queryQL(query)` - Executing SurrealQL queries
  - Handling QueryResponse and extracting results
  - Working with multiple result sets
- Parameter management:
  - `set(name, value)` - Setting query parameters
  - Using parameters in queries with `$param` syntax
- Batch operations and bulk inserts
- Info queries (`INFO FOR DB`, `version()`)

**Code Examples Needed**:
- Complete CRUD example with a person/user entity
- Raw query with WHERE clause
- Parameterized query example
- Batch insert example
- Response handling and iteration

### Section 3: Table Structures & Schema Definition
**Assigned to**: database-engineer
**Location in docs**: After QL Functions section

**Requirements**:
- Introduction to structured data and why schemas matter
- Creating `TableStructure` objects:
  - Table name
  - Field definitions with `FieldDefinition`
  - Field types (StringType, NumberType, DatetimeType, ArrayType, VectorType)
  - Optional vs required fields
  - Indexed fields
  - Default values
- Validation constraints:
  - ASSERT clauses for database-level validation
  - Common validation patterns (email, age >= 18, etc.)
- Schema validation methods:
  - `validate(data)` - Validating data against schema
  - `hasField()`, `getField()` - Schema introspection
  - `getRequiredFields()`, `getOptionalFields()`
- Schema DDL generation:
  - `toSurrealQL()` - Converting to DDL statements
- Migration strategies:
  - Auto-migration with `autoMigrate: true`
  - Manual migration with `migrate()` method
  - Dry-run preview with `migrate(dryRun: true)`
  - Understanding MigrationReport

**Code Examples Needed**:
- Basic schema definition (users table)
- Schema with validation constraints
- Schema with various field types (including arrays)
- Validation example (showing ValidationException)
- Auto-migration vs manual migration examples
- Dry-run migration example

### Section 4: Type-Safe Data with Code Generator
**Assigned to**: api-engineer
**Location in docs**: After Table Structures section

**Requirements**:
- Introduction to code generation for type safety
- Model definition with annotations:
  - `@SurrealTable('table_name')`
  - `@SurrealField(type:, assertClause:, indexed:, defaultValue:)`
  - `@SurrealId()` for ID field
  - `@SurrealRecord()` for relationships
- Setting up build_runner:
  - Adding dependencies (build_runner, surrealdartb_generator)
  - Creating `build.yaml` if needed
  - Running `dart run build_runner build`
  - Understanding generated files (*.surreal.dart)
- Using generated code:
  - `toSurrealMap()` - Serializing to database format
  - `fromSurrealMap()` - Deserializing from database
  - `validate()` - Validating model instances
  - Generated `tableDefinition` constant
- Type-safe query builders:
  - `db.query<T>()` - Creating type-safe queries
  - `.where((t) => condition)` - Type-safe where clauses
  - Available operators (equals, greaterThan, lessThan, between, etc.)
  - Combining conditions with & (AND) and | (OR)
  - `.orderBy()`, `.limit()`, `.first()`
- Working with relationships:
  - One-to-one relationships
  - One-to-many relationships (List)
  - Fetching related records

**Code Examples Needed**:
- Complete model definition with annotations (User, Post, Profile)
- build.yaml configuration
- Generated code usage (serialization/deserialization)
- Type-safe query examples (simple, complex AND, complex OR)
- Relationship example (user with posts)
- Query builder with multiple conditions

### Section 5: Vector Operations & Similarity Search
**Assigned to**: api-engineer
**Location in docs**: After Type-Safe section (final major section)

**Requirements**:
- Introduction to vector embeddings and use cases (semantic search, recommendations, etc.)
- Creating vector values:
  - `VectorValue.f32()` - Float32 vectors (most common)
  - `VectorValue.f64()` - Float64 vectors (high precision)
  - `VectorValue.i16()` - Int16 quantized vectors
  - `VectorValue.i8()` - Int8 quantized vectors
  - `VectorValue.fromList()` - Auto-detection
  - Memory comparison between formats
- Vector operations:
  - `normalize()` - Normalizing vectors
  - `isNormalized()` - Checking normalization
  - `magnitude()` - Calculating magnitude
  - `dimensions` property
  - `format` property
- Distance calculations:
  - `cosine()` - Cosine similarity
  - `euclidean()` - Euclidean distance
  - `manhattan()` - Manhattan distance
  - `dotProduct()` - Dot product
  - When to use each metric
- Storing vectors:
  - Defining vector fields in schema
  - `toJson()` - Serializing for storage
  - `fromJson()` - Deserializing from storage
  - Creating records with vector fields
- Similarity search API:
  - `searchSimilar()` - Finding similar vectors
  - Parameters (table, field, queryVector, metric, limit)
  - Understanding `SimilarityResult` (record, distance)
  - `batchSearchSimilar()` - Multiple query vectors
  - Adding filters with `where` parameter
- Performance optimization:
  - Automatic JSON vs binary serialization
  - When binary is chosen (> 100 dimensions)
  - Performance benchmarks
  - Manual serialization with `toBytes()` / `fromBytes()`
- Complete semantic search example

**Code Examples Needed**:
- Creating vectors in different formats
- Vector normalization example
- Distance calculation between vectors
- Defining schema with vector field
- Storing and retrieving vectors
- Basic similarity search
- Similarity search with filters
- Batch similarity search
- Complete semantic search workflow (store documents, search, rank results)
- Performance comparison snippet

## General Documentation Guidelines

### Style & Tone
- Clear, concise, and professional
- Assume reader is familiar with Dart but new to SurrealDB
- Explain concepts before showing code
- Use comments in code to clarify non-obvious parts
- Include "why" not just "how"

### Code Examples
- All examples must be complete and runnable
- Show imports at the top of first example in each section
- Include error handling where appropriate
- Use realistic variable names (not foo/bar)
- Show expected output as comments where helpful

### Structure
- Each section starts with brief introduction
- Organize from simple to complex
- Use subheadings for discoverability
- Include cross-references to related sections
- End each major section with "Next Steps" pointing to next section

### Best Practices
- Highlight common pitfalls and how to avoid them
- Show both correct and incorrect patterns where instructive
- Include performance considerations where relevant
- Note Flutter-specific concerns in Flutter sections

## Success Criteria
- Documentation is comprehensive enough for a developer to start using the library
- All major features are covered with working examples
- Flutter integration is clearly explained with storage path examples
- Code examples are practical and realistic
- Documentation is well-organized and easy to navigate

## Notes for Subagents
- Reference this plan to understand your section's context
- Examine test files in test/ directory for accurate usage patterns
- Examine example files in example/ directory for practical examples
- Your section should stand alone but also flow into the next section
- Use the research summary provided for accurate API details
- If you find discrepancies or unclear patterns, note them in your output
