/// High-level database API for SurrealDB.
///
/// This library provides the main Database class which offers a clean,
/// Future-based API for interacting with SurrealDB through FFI.
library;

import 'dart:async';
import 'dart:convert';
import 'dart:ffi';

import 'package:ffi/ffi.dart';

import 'exceptions.dart';
import 'ffi/bindings.dart';
import 'ffi/native_types.dart';
import 'response.dart';
import 'storage_backend.dart';
import 'types/credentials.dart';
import 'types/jwt.dart';

/// High-level asynchronous database client for SurrealDB.
///
/// This class provides a Future-based API for all database operations,
/// wrapping direct FFI calls in Future constructors to maintain async behavior
/// while avoiding the complexity and bugs of isolate-based communication.
///
/// All database operations are executed directly through FFI, which is safe
/// because the Rust layer uses runtime.block_on() to handle async operations.
///
/// Example usage:
/// ```dart
/// // Connect to an in-memory database
/// final db = await Database.connect(
///   backend: StorageBackend.memory,
///   namespace: 'test',
///   database: 'test',
/// );
///
/// try {
///   // Create a record
///   final person = await db.create('person', {
///     'name': 'John Doe',
///     'age': 30,
///   });
///
///   // Query records
///   final response = await db.query('SELECT * FROM person');
///   final results = response.getResults();
///
///   for (final record in results) {
///     print(record['name']);
///   }
/// } finally {
///   // Always close the database when done
///   await db.close();
/// }
/// ```
class Database {
  /// Creates a Database instance with a native database handle.
  ///
  /// This constructor is private. Use [Database.connect] to create
  /// a database instance.
  Database._(this._handle);

  /// The native database handle.
  Pointer<NativeDatabase> _handle;

  /// Whether the database connection has been closed.
  bool _closed = false;

  /// Connects to a SurrealDB database.
  ///
  /// This factory method creates a new database instance and establishes
  /// a connection to the specified backend. All operations are performed
  /// asynchronously through direct FFI calls wrapped in Futures.
  ///
  /// Parameters:
  /// - [backend] - The storage backend to use (memory or rocksdb)
  /// - [path] - File path for rocksdb backend (required for rocksdb, ignored for memory)
  /// - [namespace] - Optional namespace to use after connection
  /// - [database] - Optional database to use after connection
  ///
  /// Returns a connected Database instance.
  ///
  /// Throws:
  /// - [ArgumentError] if path is null for rocksdb backend
  /// - [ConnectionException] if connection fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// // In-memory database
  /// final memDb = await Database.connect(
  ///   backend: StorageBackend.memory,
  ///   namespace: 'test',
  ///   database: 'test',
  /// );
  ///
  /// // Persistent database
  /// final fileDb = await Database.connect(
  ///   backend: StorageBackend.rocksdb,
  ///   path: '/data/mydb',
  ///   namespace: 'prod',
  ///   database: 'main',
  /// );
  /// ```
  static Future<Database> connect({
    required StorageBackend backend,
    String? path,
    String? namespace,
    String? database,
  }) async {
    // Validate parameters
    if (backend.requiresPath && (path == null || path.isEmpty)) {
      throw ArgumentError.value(
        path,
        'path',
        'Path is required for ${backend.displayName} backend',
      );
    }

    return Future(() {
      // Create endpoint string
      final endpoint = backend.toEndpoint(path);
      final endpointPtr = endpoint.toNativeUtf8();

      try {
        // Create database instance
        final handle = dbNew(endpointPtr);
        if (handle == nullptr) {
          final error = _getLastErrorString();
          throw ConnectionException(error ?? 'Failed to create database instance');
        }

        // Connect to database
        final connectResult = dbConnect(handle);
        if (connectResult != 0) {
          final error = _getLastErrorString();
          dbClose(handle);
          throw ConnectionException(error ?? 'Failed to connect to database');
        }

        // Set namespace if provided
        if (namespace != null) {
          final nsPtr = namespace.toNativeUtf8();
          try {
            final nsResult = dbUseNs(handle, nsPtr);
            if (nsResult != 0) {
              final error = _getLastErrorString();
              dbClose(handle);
              throw DatabaseException(error ?? 'Failed to set namespace');
            }
          } finally {
            malloc.free(nsPtr);
          }
        }

        // Set database if provided
        if (database != null) {
          final dbPtr = database.toNativeUtf8();
          try {
            final dbResult = dbUseDb(handle, dbPtr);
            if (dbResult != 0) {
              final error = _getLastErrorString();
              dbClose(handle);
              throw DatabaseException(error ?? 'Failed to set database');
            }
          } finally {
            malloc.free(dbPtr);
          }
        }

        // Create and return database instance
        final db = Database._(handle);
        return db;
      } finally {
        malloc.free(endpointPtr);
      }
    });
  }

  /// Sets the active namespace for subsequent operations.
  ///
  /// All database operations will be executed within this namespace
  /// until changed by another call to this method.
  ///
  /// Parameters:
  /// - [namespace] - The namespace name to use
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [DatabaseException] if operation fails
  ///
  /// Example:
  /// ```dart
  /// await db.useNamespace('production');
  /// ```
  Future<void> useNamespace(String namespace) async {
    _ensureNotClosed();

    return Future(() {
      final nsPtr = namespace.toNativeUtf8();
      try {
        final result = dbUseNs(_handle, nsPtr);
        if (result != 0) {
          final error = _getLastErrorString();
          throw DatabaseException(error ?? 'Failed to set namespace');
        }
      } finally {
        malloc.free(nsPtr);
      }
    });
  }

  /// Sets the active database for subsequent operations.
  ///
  /// All database operations will be executed within this database
  /// until changed by another call to this method.
  ///
  /// Parameters:
  /// - [database] - The database name to use
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [DatabaseException] if operation fails
  ///
  /// Example:
  /// ```dart
  /// await db.useDatabase('main');
  /// ```
  Future<void> useDatabase(String database) async {
    _ensureNotClosed();

    return Future(() {
      final dbPtr = database.toNativeUtf8();
      try {
        final result = dbUseDb(_handle, dbPtr);
        if (result != 0) {
          final error = _getLastErrorString();
          throw DatabaseException(error ?? 'Failed to set database');
        }
      } finally {
        malloc.free(dbPtr);
      }
    });
  }

  /// Executes a SurrealQL query.
  ///
  /// This method executes the provided SQL query and returns a Response
  /// containing the results. The query can contain multiple statements
  /// separated by semicolons.
  ///
  /// Parameters:
  /// - [sql] - The SurrealQL query to execute
  /// - [bindings] - Optional parameter bindings (reserved for future use)
  ///
  /// Returns a Response containing the query results.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if query execution fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// final response = await db.query('''
  ///   SELECT * FROM person WHERE age > 18
  /// ''');
  ///
  /// for (final person in response.getResults()) {
  ///   print('${person['name']}: ${person['age']}');
  /// }
  /// ```
  Future<Response> query(String sql, [Map<String, dynamic>? bindings]) async {
    _ensureNotClosed();

    return Future(() {
      final sqlPtr = sql.toNativeUtf8();
      try {
        final responsePtr = dbQuery(_handle, sqlPtr);
        return _processQueryResponse(responsePtr);
      } finally {
        malloc.free(sqlPtr);
      }
    });
  }

  /// Selects all records from a table.
  ///
  /// This is a convenience method that queries all records from the
  /// specified table and returns them as a list.
  ///
  /// Parameters:
  /// - [table] - The table name to select from
  ///
  /// Returns a list of records, where each record is a Map<String, dynamic>.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if select operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// final persons = await db.select('person');
  /// for (final person in persons) {
  ///   print(person['name']);
  /// }
  /// ```
  Future<List<Map<String, dynamic>>> select(String table) async {
    _ensureNotClosed();

    return Future(() {
      final tablePtr = table.toNativeUtf8();
      try {
        final responsePtr = dbSelect(_handle, tablePtr);
        final data = _processResponse(responsePtr);

        // SELECT returns a nested array structure like CREATE/UPDATE
        // The response structure is: [[{record1}, {record2}, ...]]
        // We need to unwrap the outer array
        if (data is List && data.isNotEmpty) {
          final firstElement = data.first;
          if (firstElement is List) {
            // Unwrap the nested array
            return firstElement.cast<Map<String, dynamic>>();
          }
          // If not nested, cast directly
          return data.cast<Map<String, dynamic>>();
        }

        return [];
      } finally {
        malloc.free(tablePtr);
      }
    });
  }

  /// Creates a new record in a table.
  ///
  /// This method creates a new record with the specified data in the
  /// given table. SurrealDB will automatically generate an ID if not
  /// provided in the data.
  ///
  /// Parameters:
  /// - [table] - The table name to create the record in
  /// - [data] - The record data as key-value pairs
  ///
  /// Returns the created record including any auto-generated fields.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if create operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// final person = await db.create('person', {
  ///   'name': 'Alice',
  ///   'age': 25,
  ///   'email': 'alice@example.com',
  /// });
  ///
  /// print('Created person with ID: ${person['id']}');
  /// ```
  Future<Map<String, dynamic>> create(
    String table,
    Map<String, dynamic> data,
  ) async {
    _ensureNotClosed();

    return Future(() {
      final tablePtr = table.toNativeUtf8();
      final dataJson = jsonEncode(data);
      final dataPtr = dataJson.toNativeUtf8();

      try {
        final responsePtr = dbCreate(_handle, tablePtr, dataPtr);
        final results = _processResponse(responsePtr);

        // CREATE returns a list with one element - extract it
        if (results is! List || results.isEmpty) {
          throw QueryException('Create operation returned no results');
        }

        // SurrealDB CREATE returns an array containing the created record(s)
        // The response structure is: results = [[{record}]]
        // We need to unwrap one level: results.first = [{record}]
        final firstResult = results.first;
        if (firstResult is List) {
          final recordList = firstResult as List;
          if (recordList.isEmpty) {
            throw QueryException('Create operation returned empty result array');
          }
          return recordList.first as Map<String, dynamic>;
        }

        // Fallback: if it's already a Map, return it directly
        return firstResult as Map<String, dynamic>;
      } finally {
        malloc.free(tablePtr);
        malloc.free(dataPtr);
      }
    });
  }

  /// Updates an existing record.
  ///
  /// This method updates the record identified by [resource] with the
  /// provided data. The resource should be in the format "table:id".
  ///
  /// Parameters:
  /// - [resource] - The record identifier (e.g., "person:john")
  /// - [data] - The update data as key-value pairs
  ///
  /// Returns the updated record.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if update operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// final updated = await db.update('person:john', {
  ///   'age': 31,
  ///   'email': 'john.new@example.com',
  /// });
  ///
  /// print('Updated: ${updated['name']}');
  /// ```
  Future<Map<String, dynamic>> update(
    String resource,
    Map<String, dynamic> data,
  ) async {
    _ensureNotClosed();

    return Future(() {
      final resourcePtr = resource.toNativeUtf8();
      final dataJson = jsonEncode(data);
      final dataPtr = dataJson.toNativeUtf8();

      try {
        final responsePtr = dbUpdate(_handle, resourcePtr, dataPtr);
        final results = _processResponse(responsePtr);

        // UPDATE returns a list - extract first element
        if (results is! List || results.isEmpty) {
          throw QueryException('Update operation returned no results');
        }

        // SurrealDB UPDATE returns an array containing the updated record(s)
        // The response structure is: results = [[{record}]]
        // We need to unwrap one level: results.first = [{record}]
        final firstResult = results.first;
        if (firstResult is List) {
          final recordList = firstResult as List;
          if (recordList.isEmpty) {
            throw QueryException('Update operation returned empty result array');
          }
          return recordList.first as Map<String, dynamic>;
        }

        // Fallback: if it's already a Map, return it directly
        return firstResult as Map<String, dynamic>;
      } finally {
        malloc.free(resourcePtr);
        malloc.free(dataPtr);
      }
    });
  }

  /// Deletes a record.
  ///
  /// This method deletes the record identified by [resource].
  /// The resource should be in the format "table:id".
  ///
  /// Parameters:
  /// - [resource] - The record identifier (e.g., "person:john")
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if delete operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// await db.delete('person:john');
  /// print('Deleted person:john');
  /// ```
  Future<void> delete(String resource) async {
    _ensureNotClosed();

    return Future(() {
      final resourcePtr = resource.toNativeUtf8();
      try {
        final responsePtr = dbDelete(_handle, resourcePtr);
        // Process response to check for errors, but don't return data
        _processResponse(responsePtr);
      } finally {
        malloc.free(resourcePtr);
      }
    });
  }

  /// Gets a specific record by resource identifier.
  ///
  /// This method retrieves a single record identified by [resource].
  /// The resource should be in the format "table:id".
  ///
  /// Unlike other operations, this method returns null if the record
  /// does not exist, rather than throwing an exception.
  ///
  /// Parameters:
  /// - [resource] - The record identifier (e.g., "person:alice")
  ///
  /// Returns the record if it exists, null otherwise.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [DatabaseException] if resource parameter is invalid
  /// - [QueryException] if get operation fails
  ///
  /// Example:
  /// ```dart
  /// final person = await db.get<Map<String, dynamic>>('person:alice');
  /// if (person != null) {
  ///   print('Found: ${person['name']}');
  /// } else {
  ///   print('Person not found');
  /// }
  /// ```
  Future<T?> get<T>(String resource) async {
    _ensureNotClosed();

    return Future(() {
      final resourcePtr = resource.toNativeUtf8();
      try {
        final responsePtr = dbGet(_handle, resourcePtr);
        final data = _processResponse(responsePtr);

        // GET returns a nested array structure similar to SELECT
        // The response structure is: [[{record}]] or [[]] if not found
        // We need to unwrap and handle the null case
        if (data is List && data.isNotEmpty) {
          final firstElement = data.first;
          if (firstElement is List) {
            final recordList = firstElement as List;
            if (recordList.isEmpty) {
              // Record not found
              return null;
            }
            // Return first record as type T
            return recordList.first as T?;
          }
          // If not nested, return directly
          return firstElement as T?;
        }

        // Empty response means record not found
        return null;
      } finally {
        malloc.free(resourcePtr);
      }
    });
  }

  /// Signs in with credentials and returns a JWT token.
  ///
  /// This method authenticates a user with the provided credentials and
  /// returns a JWT token that can be used for subsequent authenticated
  /// operations.
  ///
  /// Parameters:
  /// - [credentials] - The credentials to authenticate with
  ///
  /// Returns a JWT token on successful authentication.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [AuthenticationException] if authentication fails
  /// - [DatabaseException] for other errors
  ///
  /// Embedded Mode Limitations:
  /// - Authentication may have reduced functionality in embedded mode
  /// - Scope-based access control may not fully apply
  /// - Token refresh is not supported
  ///
  /// Example:
  /// ```dart
  /// final jwt = await db.signin(RootCredentials('root', 'rootpass'));
  /// print('Authenticated with token');
  /// ```
  Future<Jwt> signin(Credentials credentials) async {
    _ensureNotClosed();

    return Future(() {
      final credentialsJson = jsonEncode(credentials.toJson());
      final credentialsPtr = credentialsJson.toNativeUtf8();

      try {
        final tokenPtr = dbSignin(_handle, credentialsPtr);
        if (tokenPtr == nullptr) {
          final error = _getLastErrorString();
          throw AuthenticationException(error ?? 'Signin failed');
        }

        try {
          final tokenJsonStr = tokenPtr.toDartString();
          final tokenJson = jsonDecode(tokenJsonStr);
          return Jwt.fromJson(tokenJson);
        } finally {
          freeString(tokenPtr);
        }
      } finally {
        malloc.free(credentialsPtr);
      }
    });
  }

  /// Signs up a new user with scope credentials and returns a JWT token.
  ///
  /// This method creates a new user account within a scope and returns
  /// a JWT token for the newly created user.
  ///
  /// Parameters:
  /// - [credentials] - The scope or record credentials for signup
  ///
  /// Returns a JWT token for the newly created user.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [AuthenticationException] if signup fails
  /// - [ArgumentError] if credentials are not scope or record credentials
  /// - [DatabaseException] for other errors
  ///
  /// Embedded Mode Limitations:
  /// - Signup functionality may be limited in embedded mode
  /// - User creation and scope-based authentication may not work as expected
  ///
  /// Example:
  /// ```dart
  /// final jwt = await db.signup(ScopeCredentials(
  ///   'myNamespace',
  ///   'myDatabase',
  ///   'user_scope',
  ///   {'email': 'user@example.com', 'password': 'pass123'},
  /// ));
  /// print('User created and authenticated');
  /// ```
  Future<Jwt> signup(Credentials credentials) async {
    _ensureNotClosed();

    // Validate that credentials are scope or record credentials
    if (credentials is! ScopeCredentials && credentials is! RecordCredentials) {
      throw ArgumentError(
        'Signup only accepts ScopeCredentials or RecordCredentials',
      );
    }

    return Future(() {
      final credentialsJson = jsonEncode(credentials.toJson());
      final credentialsPtr = credentialsJson.toNativeUtf8();

      try {
        final tokenPtr = dbSignup(_handle, credentialsPtr);
        if (tokenPtr == nullptr) {
          final error = _getLastErrorString();
          throw AuthenticationException(error ?? 'Signup failed');
        }

        try {
          final tokenJsonStr = tokenPtr.toDartString();
          final tokenJson = jsonDecode(tokenJsonStr);
          return Jwt.fromJson(tokenJson);
        } finally {
          freeString(tokenPtr);
        }
      } finally {
        malloc.free(credentialsPtr);
      }
    });
  }

  /// Authenticates with an existing JWT token.
  ///
  /// This method authenticates the current session using a previously
  /// obtained JWT token. This is useful for resuming sessions or
  /// authenticating with tokens obtained from signin or signup.
  ///
  /// Parameters:
  /// - [token] - The JWT token to authenticate with
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [AuthenticationException] if authentication fails
  /// - [DatabaseException] for other errors
  ///
  /// Embedded Mode Limitations:
  /// - Token-based authentication may have limited functionality
  /// - Token validation may not work as expected
  ///
  /// Example:
  /// ```dart
  /// final jwt = await db.signin(credentials);
  /// // ... later or in another session ...
  /// await db.authenticate(jwt);
  /// print('Session authenticated');
  /// ```
  Future<void> authenticate(Jwt token) async {
    _ensureNotClosed();

    return Future(() {
      final tokenStr = token.asInsecureToken();
      final tokenPtr = tokenStr.toNativeUtf8();

      try {
        final result = dbAuthenticate(_handle, tokenPtr);
        if (result != 0) {
          final error = _getLastErrorString();
          throw AuthenticationException(error ?? 'Authentication failed');
        }
      } finally {
        malloc.free(tokenPtr);
      }
    });
  }

  /// Invalidates the current authentication session.
  ///
  /// This method clears the current authentication state, effectively
  /// logging out the current user. After calling this method, authenticated
  /// operations will fail until a new signin or authenticate is performed.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [AuthenticationException] if invalidation fails
  /// - [DatabaseException] for other errors
  ///
  /// Embedded Mode Limitations:
  /// - Session invalidation may have limited effect in embedded mode
  /// - Authentication state is managed differently than in remote server mode
  ///
  /// Example:
  /// ```dart
  /// await db.invalidate();
  /// print('Session invalidated');
  /// ```
  Future<void> invalidate() async {
    _ensureNotClosed();

    return Future(() {
      final result = dbInvalidate(_handle);
      if (result != 0) {
        final error = _getLastErrorString();
        throw AuthenticationException(error ?? 'Invalidate failed');
      }
    });
  }


  /// Sets a query parameter that can be used in subsequent queries.
  ///
  /// Parameters are stored per connection and can be referenced in queries
  /// using the syntax $paramName. This is useful for creating reusable
  /// parameterized queries and avoiding SQL injection.
  ///
  /// Parameters:
  /// - [name] - The parameter name (without the $ prefix)
  /// - [value] - The parameter value (can be any JSON-serializable type)
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [ParameterException] if parameter operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// await db.set('user_id', 'person:alice');
  /// await db.set('min_age', 18);
  ///
  /// // Use parameters in queries
  /// final response = await db.query(
  ///   'SELECT * FROM person WHERE id = $user_id AND age >= $min_age'
  /// );
  /// ```
  Future<void> set(String name, dynamic value) async {
    _ensureNotClosed();

    return Future(() {
      final namePtr = name.toNativeUtf8();
      final valueJson = jsonEncode(value);
      final valuePtr = valueJson.toNativeUtf8();

      try {
        final result = dbSet(_handle, namePtr, valuePtr);
        if (result != 0) {
          final error = _getLastErrorString();
          throw ParameterException(error ?? 'Failed to set parameter');
        }
      } finally {
        malloc.free(namePtr);
        malloc.free(valuePtr);
      }
    });
  }

  /// Removes a query parameter from the connection.
  ///
  /// If the parameter doesn't exist, this method completes successfully
  /// without error.
  ///
  /// Parameters:
  /// - [name] - The parameter name to remove (without the $ prefix)
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [ParameterException] if parameter operation fails
  /// - [DatabaseException] for other errors
  ///
  /// Example:
  /// ```dart
  /// await db.set('temp_value', 42);
  /// // ... use the parameter ...
  /// await db.unset('temp_value');
  /// ```
  Future<void> unset(String name) async {
    _ensureNotClosed();

    return Future(() {
      final namePtr = name.toNativeUtf8();

      try {
        final result = dbUnset(_handle, namePtr);
        if (result != 0) {
          final error = _getLastErrorString();
          throw ParameterException(error ?? 'Failed to unset parameter');
        }
      } finally {
        malloc.free(namePtr);
      }
    });
  }

  /// Executes a SurrealQL function and returns the result.
  ///
  /// This method can execute both built-in SurrealQL functions (like
  /// rand::float, time::now, etc.) and user-defined functions. The result
  /// type is determined by the generic type parameter T.
  ///
  /// Parameters:
  /// - [function] - The function name (e.g., "rand::float", "fn::my_function")
  /// - [args] - Optional list of arguments to pass to the function
  ///
  /// Returns the function result, deserialized to type T.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [QueryException] if function execution fails
  /// - [DatabaseException] for other errors
  ///
  /// Examples:
  /// ```dart
  /// // Execute built-in function with no arguments
  /// final randomValue = await db.run<double>('rand::float');
  ///
  /// // Execute function with arguments
  /// final upperCase = await db.run<String>('string::uppercase', ['hello']);
  ///
  /// // Execute user-defined function
  /// final result = await db.run<Map<String, dynamic>>(
  ///   'fn::calculate_tax',
  ///   [100.0, 0.08],
  /// );
  /// ```
  Future<T> run<T>(String function, [List<dynamic>? args]) async {
    _ensureNotClosed();

    return Future(() {
      final functionPtr = function.toNativeUtf8();
      final argsJson = args != null && args.isNotEmpty 
          ? jsonEncode(args) 
          : '';
      final argsPtr = argsJson.toNativeUtf8();

      try {
        final responsePtr = dbRun(_handle, functionPtr, argsPtr);
        final data = _processResponse(responsePtr);

        // Function results are wrapped in an array structure
        // Similar to query results: [[result]]
        if (data is List && data.isNotEmpty) {
          final firstElement = data.first;
          if (firstElement is List && firstElement.isNotEmpty) {
            return firstElement.first as T;
          }
          return firstElement as T;
        }

        throw QueryException('Function returned no results');
      } finally {
        malloc.free(functionPtr);
        malloc.free(argsPtr);
      }
    });
  }

  /// Gets the database version string.
  ///
  /// Returns a version string like "1.5.0" representing the SurrealDB
  /// server/engine version.
  ///
  /// Returns the database version string.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [DatabaseException] if version query fails
  ///
  /// Example:
  /// ```dart
  /// final version = await db.version();
  /// print('SurrealDB version: $version');
  /// ```
  Future<String> version() async {
    _ensureNotClosed();

    return Future(() {
      final versionPtr = dbVersion(_handle);
      if (versionPtr == nullptr) {
        final error = _getLastErrorString();
        throw DatabaseException(error ?? 'Failed to get version');
      }

      try {
        return versionPtr.toDartString();
      } finally {
        freeString(versionPtr);
      }
    });

  /// Executes a transaction with automatic commit/rollback.
  ///
  /// This method provides transactional semantics by wrapping the callback
  /// execution in a BEGIN TRANSACTION...COMMIT TRANSACTION block. If the
  /// callback throws an exception, the transaction is automatically rolled back.
  ///
  /// All database operations performed within the callback function operate
  /// within the transaction scope using the same database handle.
  ///
  /// Parameters:
  /// - [callback] - Async function that performs database operations
  ///
  /// Returns the value returned by the callback function.
  ///
  /// Throws:
  /// - [StateError] if database is closed
  /// - [TransactionException] if begin, commit, or rollback fails
  /// - Any exception thrown by the callback (after rollback)
  ///
  /// Example:
  /// ```dart
  /// final result = await db.transaction((txn) async {
  ///   // Create account
  ///   final account = await txn.create("account", {"balance": 100});
  ///   // Create related transaction record
  ///   await txn.create("transaction", {
  ///     "account_id": account["id"],
  ///     "amount": 100,
  ///     "type": "deposit"
  ///   });
  ///   return account;
  /// });
  /// // If any operation fails, both creates are rolled back
  /// print("Account created: ${result["id"]}");
  /// ```
  Future<T> transaction<T>(Future<T> Function(Database txn) callback) async {
    _ensureNotClosed();

    return Future(() async {
      // BEGIN TRANSACTION
      final beginResult = dbBegin(_handle);
      if (beginResult != 0) {
        final error = _getLastErrorString();
        throw TransactionException(error ?? "Failed to begin transaction");
      }

      try {
        // Execute callback with this database instance
        // The callback uses the same handle which is now in transaction mode
        final result = await callback(this);

        // COMMIT TRANSACTION
        final commitResult = dbCommit(_handle);
        if (commitResult != 0) {
          final error = _getLastErrorString();
          throw TransactionException(error ?? "Failed to commit transaction");
        }

        return result;
      } catch (e) {
        // ROLLBACK TRANSACTION on any exception
        try {
          final rollbackResult = dbRollback(_handle);
          if (rollbackResult != 0) {
            final error = _getLastErrorString();
            // Log rollback failure but rethrow original exception
            print("Warning: Rollback failed: $error");
          }
        } catch (_) {
          // Ignore rollback errors and rethrow original exception
        }
        rethrow;
      }
    });
  }
  }

  /// Closes the database connection and releases resources.
  ///
  /// After calling this method, the database instance cannot be used anymore.
  /// All subsequent operations will throw a [StateError].
  ///
  /// It is recommended to call this method in a finally block to ensure
  /// cleanup even if exceptions occur.
  ///
  /// This method is idempotent - calling it multiple times is safe.
  ///
  /// Implementation note: This method includes a small delay after closing
  /// to ensure the Rust runtime has time to complete async cleanup tasks
  /// and release resources (especially important for RocksDB file locks).
  ///
  /// Example:
  /// ```dart
  /// final db = await Database.connect(backend: StorageBackend.memory);
  /// try {
  ///   // Use database
  /// } finally {
  ///   await db.close();
  /// }
  /// ```
  Future<void> close() async {
    if (_closed) {
      return; // Already closed
    }

    _closed = true;

    return Future(() async {
      try {
        // Close the native database handle
        dbClose(_handle);

        // Add a delay to ensure async cleanup completes
        // This is especially important for RocksDB to release file locks
        // The Rust layer does internal cleanup, but this extra delay
        // provides a safety margin for the async runtime to finish
        // and for RocksDB to fully release file system resources
        //
        // This delay is on top of the 500ms delay in the Rust layer
        await Future.delayed(const Duration(milliseconds: 200));
      } catch (_) {
        // Ignore errors during cleanup
      }
    });
  }

  /// Whether the database connection has been closed.
  ///
  /// Once closed, the database instance cannot be used anymore.
  ///
  /// Example:
  /// ```dart
  /// if (db.isClosed) {
  ///   print('Database is closed');
  /// }
  /// ```
  bool get isClosed => _closed;

  /// Ensures the database is not closed.
  ///
  /// Throws [StateError] if the database has been closed.
  void _ensureNotClosed() {
    if (_closed) {
      throw StateError('Database connection has been closed');
    }
  }

  /// Processes a Response pointer from FFI and returns the data.
  ///
  /// This method extracts JSON data from the native response and frees
  /// the response pointer after processing.
  ///
  /// Throws [QueryException] if the response indicates an error.
  dynamic _processResponse(Pointer<NativeResponse> responsePtr) {
    if (responsePtr == nullptr) {
      final error = _getLastErrorString();
      throw QueryException(error ?? 'Operation failed');
    }

    try {
      // Check if response has errors
      final hasErrors = responseHasErrors(responsePtr);
      if (hasErrors != 0) {
        final error = _getLastErrorString();
        throw QueryException(error ?? 'Query execution failed');
      }

      // Extract JSON from response
      final jsonPtr = responseGetResults(responsePtr);
      if (jsonPtr == nullptr) {
        throw QueryException('Failed to get response results');
      }

      try {
        final jsonStr = jsonPtr.toDartString();
        return jsonDecode(jsonStr);
      } finally {
        freeString(jsonPtr);
      }
    } finally {
      responseFree(responsePtr);
    }
  }

  /// Processes a query Response pointer and returns a Response object.
  ///
  /// This is specifically for the query() method which returns a Response
  /// object rather than raw data.
  Response _processQueryResponse(Pointer<NativeResponse> responsePtr) {
    if (responsePtr == nullptr) {
      final error = _getLastErrorString();
      throw QueryException(error ?? 'Query failed');
    }

    try {
      // Check if response has errors
      final hasErrors = responseHasErrors(responsePtr);
      if (hasErrors != 0) {
        final error = _getLastErrorString();
        throw QueryException(error ?? 'Query execution failed');
      }

      // Extract JSON from response
      final jsonPtr = responseGetResults(responsePtr);
      if (jsonPtr == nullptr) {
        throw QueryException('Failed to get query results');
      }

      try {
        final jsonStr = jsonPtr.toDartString();
        final data = jsonDecode(jsonStr);
        return Response(data);
      } finally {
        freeString(jsonPtr);
      }
    } finally {
      responseFree(responsePtr);
    }
  }

  /// Gets the last error string from native code and frees it.
  ///
  /// Returns null if no error string is available.
  static String? _getLastErrorString() {
    final errorPtr = getLastError();
    if (errorPtr == nullptr) {
      return null;
    }

    try {
      return errorPtr.toDartString();
    } finally {
      freeString(errorPtr);
    }
  }
}